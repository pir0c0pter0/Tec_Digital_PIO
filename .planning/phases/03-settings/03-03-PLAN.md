---
phase: 03-settings
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/main.cpp
  - src/services/ble/ble_service.cpp
autonomous: true

must_haves:
  truths:
    - "User can open Settings screen from menu button and adjust volume/brightness with immediate effect"
    - "When BLE client writes volume, device applies it and SettingsScreen (if active) updates slider position"
    - "When BLE client writes brightness, device applies it and SettingsScreen (if active) updates slider position"
    - "When user changes volume/brightness on touchscreen, BLE client receives notification with new value"
    - "Driver names written via BLE are persisted in NVS via config event queue processing"
    - "Time sync written via BLE sets system clock via settimeofday()"
    - "BLE subscribe events for config volume/brightness are routed to gatt_config module"
    - "Config events are processed in main loop alongside existing BLE events"
  artifacts:
    - path: "src/main.cpp"
      provides: "SettingsScreen registered, config event processing in main loop, BLE notification triggers from slider callbacks"
      contains: "config_process_events"
    - path: "src/services/ble/ble_service.cpp"
      provides: "Config subscription routing + connection handle management for config module"
      contains: "gatt_config_update_subscription"
  key_links:
    - from: "src/main.cpp"
      to: "gatt_config.h"
      via: "config_process_events() in main loop, notify_config_volume/brightness in slider sync"
      pattern: "config_process_events"
    - from: "src/main.cpp"
      to: "settings_screen.h"
      via: "Static SettingsScreen instance registered with ScreenManager, updateVolumeSlider/updateBrightnessSlider called from config event handler"
      pattern: "settingsScreen"
    - from: "src/services/ble/ble_service.cpp"
      to: "gatt_config.h"
      via: "gatt_config_set_conn_handle in CONNECT/DISCONNECT, gatt_config_update_subscription in SUBSCRIBE, gatt_config_reset_subscriptions in DISCONNECT"
      pattern: "gatt_config_set_conn_handle"
    - from: "src/main.cpp (slider callbacks)"
      to: "notify_config_volume/brightness"
      via: "SettingsScreen slider callbacks call notify functions after NVS save"
      pattern: "notify_config_volume"
---

<objective>
Wire the SettingsScreen and GATT Configuration Service into main.cpp and ble_service.cpp for complete bidirectional sync.

Purpose: This plan connects all the pieces built in 03-01 and 03-02: registers SettingsScreen with the screen manager, routes BLE subscribe events to the config module, processes config events in the main loop (applying hardware changes, NVS persistence, and UI updates), and adds BLE notification calls to the SettingsScreen slider callbacks. After this plan, the full bidirectional flow works: touchscreen changes push to BLE, BLE writes push to touchscreen.

Output: Complete Phase 3 integration in main.cpp and ble_service.cpp.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/03-settings/03-RESEARCH.md
@.planning/phases/03-settings/03-01-SUMMARY.md
@.planning/phases/03-settings/03-02-SUMMARY.md

@src/main.cpp
@src/services/ble/ble_service.cpp
@include/services/ble/gatt/gatt_config.h
@include/ui/screens/settings_screen.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire SettingsScreen + config events into main.cpp</name>
  <files>
    src/main.cpp
  </files>
  <action>
**New includes (after existing BLE includes):**
```cpp
#include "services/ble/gatt/gatt_config.h"
#include "ui/screens/settings_screen.h"
#include <sys/time.h>
```

**New static variable (after numpadScreen declaration):**
```cpp
static SettingsScreen settingsScreen;
```

**New config event handler function (after onBleEvent, before system_task):**

```cpp
static void onConfigEvent(const ConfigEvent& evt) {
    auto* nvsMgr = NvsManager::getInstance();

    switch (evt.type) {
        case CONFIG_EVT_VOLUME: {
            ESP_LOGI(TAG, "Config BLE: volume=%d", evt.value_u8);
            // 1. Apply hardware change
            setAudioVolume(evt.value_u8);
            // 2. Persist to NVS
            nvsMgr->saveVolume(evt.value_u8);
            // 3. Notify BLE client (echo back)
            notify_config_volume();
            // 4. Update SettingsScreen UI if active
            if (screenMgr && screenMgr->getCurrentScreen() == ScreenType::SETTINGS) {
                settingsScreen.updateVolumeSlider(evt.value_u8);
            }
            break;
        }
        case CONFIG_EVT_BRIGHTNESS: {
            ESP_LOGI(TAG, "Config BLE: brightness=%d", evt.value_u8);
            bsp_display_brightness_set(evt.value_u8);
            nvsMgr->saveBrightness(evt.value_u8);
            notify_config_brightness();
            if (screenMgr && screenMgr->getCurrentScreen() == ScreenType::SETTINGS) {
                settingsScreen.updateBrightnessSlider(evt.value_u8);
            }
            break;
        }
        case CONFIG_EVT_DRIVER_NAME: {
            ESP_LOGI(TAG, "Config BLE: driver %d name='%s'", evt.driver_id, evt.name);
            nvsMgr->saveDriverName(evt.driver_id, evt.name);
            break;
        }
        case CONFIG_EVT_TIME_SYNC: {
            ESP_LOGI(TAG, "Config BLE: time sync=%lu", (unsigned long)evt.value_u32);
            struct timeval tv = {
                .tv_sec = (time_t)evt.value_u32,
                .tv_usec = 0,
            };
            settimeofday(&tv, NULL);
            break;
        }
    }
}
```

**In system_task -- SettingsScreen registration (after numpadScreen.create()):**

Add after existing screen registrations and creates:
```cpp
// Registra SettingsScreen
screenMgr->registerScreen(&settingsScreen);
settingsScreen.create();
```

Note: Do NOT call settingsScreen.setStatusBar() -- SettingsScreen does not use ButtonManager/StatusBar delegation (it creates its own widgets directly). Settings screen does not need StatusBar reference.

**In system_task -- Config event queue init (after BLE init success):**

Add inside the `if (!bleSvc->init())` else block, after the advertising log:
```cpp
// Inicializa fila de eventos de configuracao
config_event_queue_init();
```

**In system_task main loop -- Add config event processing (after ble_process_events):**

```cpp
// Processa eventos de configuracao BLE
config_process_events(onConfigEvent);
```

**Add BLE notification calls to SettingsScreen slider callbacks:**

This requires modifying settings_screen.cpp (from Plan 03-01). In the volume slider callback, after the NVS save line, add:
```cpp
notify_config_volume();
```

In the brightness slider callback, after the NVS save line, add:
```cpp
notify_config_brightness();
```

Wait -- settings_screen.cpp is already created in Plan 03-01. The plan 03-01 action explicitly says "(BLE notification will be added in Plan 03-03)". So we need to add the notify calls.

However, to avoid modifying settings_screen.cpp directly (which would conflict with 03-01's files_modified list), the notify calls should be added as part of the slider callbacks in settings_screen.cpp. Since this plan depends on 03-01, the file exists and we can modify it.

Actually, the simplest approach: add `#include "services/ble/gatt/gatt_config.h"` to settings_screen.cpp and add `notify_config_volume()` / `notify_config_brightness()` calls in the existing slider callbacks after the NVS save. This is a 4-line addition to an existing file.

**Modify src/ui/screens/settings_screen.cpp:**
1. Add include: `#include "services/ble/gatt/gatt_config.h"`
2. In volume slider callback, after NvsManager::getInstance()->saveVolume(value): add `notify_config_volume();`
3. In brightness slider callback, after NvsManager::getInstance()->saveBrightness(value): add `notify_config_brightness();`

**Update menu button cycling in StatusBar:**

The current menu button cycles JORNADA <-> NUMPAD. It needs to include SETTINGS in the cycle. However, per the project decisions, the menu button in StatusBar uses cycleTo() which replaces current screen without using the navigation stack. The settings screen should be accessed via navigateTo() (push onto stack) with a dedicated entry.

For Phase 3, the approach is:
- Menu button in StatusBar cycles: NUMPAD -> JORNADA -> SETTINGS -> NUMPAD (3-way cycle)
- OR: Add SETTINGS to the cycle list

Check how StatusBar menu currently works. The StatusBar uses IScreenManager::cycleTo() for JORNADA <-> NUMPAD. To add SETTINGS, we modify the cycle logic in status_bar.cpp.

Actually, let me reconsider. The research and roadmap say "User can open the Settings screen from the menu." The simplest approach that preserves existing behavior:
- Current cycle: NUMPAD <-> JORNADA (2 screens)
- New cycle: NUMPAD -> JORNADA -> SETTINGS -> NUMPAD (3-way cycle)

This means modifying `src/ui/widgets/status_bar.cpp` to add SETTINGS to the cycle sequence. The menu button callback checks current screen and cycles to next:
- If NUMPAD -> cycleTo(JORNADA)
- If JORNADA -> cycleTo(SETTINGS)
- If SETTINGS -> cycleTo(NUMPAD)

**Modify src/ui/widgets/status_bar.cpp:**
Find the menu button callback. Currently it alternates between NUMPAD and JORNADA. Change to:
- getCurrentScreen() == NUMPAD -> cycleTo(JORNADA)
- getCurrentScreen() == JORNADA -> cycleTo(SETTINGS)
- getCurrentScreen() == SETTINGS -> cycleTo(NUMPAD)
- default -> cycleTo(NUMPAD)

**Update system_task log:**
Change "Sistema Pronto!" log to include Settings screen info.
  </action>
  <verify>
pio run -- build succeeds.
Grep for "settingsScreen" in main.cpp (static instance declared and registered).
Grep for "config_process_events" in main.cpp (main loop consumer wired).
Grep for "onConfigEvent" in main.cpp (handler function exists).
Grep for "config_event_queue_init" in main.cpp (queue initialized).
Grep for "notify_config_volume" in settings_screen.cpp (BLE notification from slider).
Grep for "SETTINGS" in status_bar.cpp (menu cycling includes settings).
  </verify>
  <done>
SettingsScreen statically allocated and registered with ScreenManager. Config event queue initialized after BLE init. Config events processed every 5ms in main loop: volume changes apply audio + NVS + notify BLE + update UI, brightness changes apply backlight + NVS + notify BLE + update UI, driver names persist to NVS, time sync sets system clock. SettingsScreen slider callbacks trigger BLE notifications. Menu button cycles through NUMPAD -> JORNADA -> SETTINGS. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route config subscribe events in ble_service.cpp</name>
  <files>
    src/services/ble/ble_service.cpp
  </files>
  <action>
**Add include (after existing gatt_journey.h include):**
```cpp
#include "services/ble/gatt/gatt_config.h"
```

**In GAP event handler -- BLE_GAP_EVENT_CONNECT (success path):**

After existing `gatt_journey_set_conn_handle(event->connect.conn_handle)`:
```cpp
gatt_config_set_conn_handle(event->connect.conn_handle);
```

**In GAP event handler -- BLE_GAP_EVENT_DISCONNECT:**

After existing `gatt_journey_set_conn_handle(0)` and `gatt_journey_reset_subscriptions()`:
```cpp
gatt_config_set_conn_handle(0);
gatt_config_reset_subscriptions();
```

**In GAP event handler -- BLE_GAP_EVENT_SUBSCRIBE:**

After existing call to `gatt_journey_update_subscription(...)`:
```cpp
// Route config characteristic subscriptions
gatt_config_update_subscription(
    event->subscribe.attr_handle,
    event->subscribe.cur_notify
);
```

Note: Both journey and config modules check if the attr_handle matches their own characteristics. If it does not match, they silently ignore it. So calling both is safe and correct.

**No other changes needed.** The existing GAP handler structure supports this modular pattern -- each GATT module registers its own subscription tracking.
  </action>
  <verify>
pio run -- build succeeds.
Grep for "gatt_config_set_conn_handle" in ble_service.cpp (CONNECT and DISCONNECT paths).
Grep for "gatt_config_update_subscription" in ble_service.cpp (SUBSCRIBE handler).
Grep for "gatt_config_reset_subscriptions" in ble_service.cpp (DISCONNECT cleanup).
  </verify>
  <done>
BLE service routes connection/subscription events to config module. On CONNECT: sets config conn_handle. On SUBSCRIBE: routes attr_handle to config module for per-characteristic tracking. On DISCONNECT: clears config conn_handle and resets all config subscriptions. Both journey and config modules coexist in the same GAP handler. Build passes.
  </done>
</task>

</tasks>

<verification>
- `pio run` succeeds with zero errors
- Full bidirectional flow works:
  - Touchscreen -> BLE: slider change -> setAudioVolume/bsp_display_brightness_set -> NVS save -> notify_config_volume/brightness
  - BLE -> Touchscreen: GATT write -> config_post_event -> queue -> onConfigEvent -> hardware apply -> NVS save -> update SettingsScreen UI
- Config events processed in main loop (config_process_events in while(1))
- BLE subscribe events routed to config module (gatt_config_update_subscription in ble_service.cpp)
- SettingsScreen accessible via menu button cycling (NUMPAD -> JORNADA -> SETTINGS)
- Driver names from BLE persisted in NVS
- Time sync from BLE sets system clock
</verification>

<success_criteria>
- Build passes (pio run exits 0)
- SettingsScreen registered and accessible from menu
- Config event handler processes all 4 event types (volume, brightness, driver name, time sync)
- BLE notifications sent when user changes volume/brightness on touchscreen
- SettingsScreen sliders update when BLE client writes new values (only if screen active)
- ble_service.cpp routes subscribe events to both journey and config modules
- No feedback loops (updatingFromExternal_ flag prevents slider -> notify -> event -> slider cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/03-settings/03-03-SUMMARY.md`
</output>
