---
phase: 03-settings
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/main.cpp
  - src/services/ble/ble_service.cpp
  - src/ui/screens/settings_screen.cpp
  - src/ui/widgets/status_bar.cpp
autonomous: true

must_haves:
  truths:
    - "User can open Settings screen from menu button and adjust volume/brightness with immediate effect"
    - "When BLE client writes volume, device applies it and SettingsScreen (if active) updates slider position"
    - "When BLE client writes brightness, device applies it and SettingsScreen (if active) updates slider position"
    - "When user changes volume/brightness on touchscreen, BLE client receives notification with new value"
    - "Driver names written via BLE are persisted in NVS via config event queue processing"
    - "Time sync written via BLE sets system clock via settimeofday()"
    - "BLE subscribe events for config volume/brightness are routed to gatt_config module"
    - "Config events are processed in main loop alongside existing BLE events"
  artifacts:
    - path: "src/main.cpp"
      provides: "SettingsScreen registered, config event processing in main loop, onConfigEvent handler"
      contains: "config_process_events"
    - path: "src/services/ble/ble_service.cpp"
      provides: "Config subscription routing + connection handle management for config module"
      contains: "gatt_config_update_subscription"
    - path: "src/ui/screens/settings_screen.cpp"
      provides: "BLE notification calls from slider callbacks"
      contains: "notify_config_volume"
    - path: "src/ui/widgets/status_bar.cpp"
      provides: "3-way menu cycling including SETTINGS"
      contains: "SETTINGS"
  key_links:
    - from: "src/main.cpp"
      to: "gatt_config.h"
      via: "config_process_events() in main loop, notify_config_volume/brightness in slider sync"
      pattern: "config_process_events"
    - from: "src/main.cpp"
      to: "settings_screen.h"
      via: "Static SettingsScreen instance registered with ScreenManager, updateVolumeSlider/updateBrightnessSlider called from config event handler"
      pattern: "settingsScreen"
    - from: "src/services/ble/ble_service.cpp"
      to: "gatt_config.h"
      via: "gatt_config_set_conn_handle in CONNECT/DISCONNECT, gatt_config_update_subscription in SUBSCRIBE, gatt_config_reset_subscriptions in DISCONNECT"
      pattern: "gatt_config_set_conn_handle"
    - from: "src/ui/screens/settings_screen.cpp"
      to: "gatt_config.h"
      via: "notify_config_volume/brightness calls after NVS save in slider callbacks"
      pattern: "notify_config_volume"
    - from: "src/ui/widgets/status_bar.cpp"
      to: "ScreenType::SETTINGS"
      via: "Menu button callback cycles NUMPAD -> JORNADA -> SETTINGS -> NUMPAD"
      pattern: "SETTINGS"
---

<objective>
Wire the SettingsScreen and GATT Configuration Service into main.cpp and ble_service.cpp for complete bidirectional sync, add BLE notifications to SettingsScreen slider callbacks, and include SETTINGS in the StatusBar menu cycle.

Purpose: This plan connects all the pieces built in 03-01 and 03-02: registers SettingsScreen with the screen manager, routes BLE subscribe events to the config module, processes config events in the main loop (applying hardware changes, NVS persistence, and UI updates), adds BLE notification calls to the SettingsScreen slider callbacks, and adds SETTINGS to the menu button cycle. After this plan, the full bidirectional flow works: touchscreen changes push to BLE, BLE writes push to touchscreen.

Output: Complete Phase 3 integration across main.cpp, ble_service.cpp, settings_screen.cpp, and status_bar.cpp.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/03-settings/03-RESEARCH.md
@.planning/phases/03-settings/03-01-SUMMARY.md
@.planning/phases/03-settings/03-02-SUMMARY.md

@src/main.cpp
@src/services/ble/ble_service.cpp
@include/services/ble/gatt/gatt_config.h
@include/ui/screens/settings_screen.h
@src/ui/screens/settings_screen.cpp
@src/ui/widgets/status_bar.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire SettingsScreen + config events into main.cpp</name>
  <files>
    src/main.cpp
  </files>
  <action>
**New includes (after existing BLE includes):**
```cpp
#include "services/ble/gatt/gatt_config.h"
#include "ui/screens/settings_screen.h"
#include <sys/time.h>
```

**New static variable (after numpadScreen declaration):**
```cpp
static SettingsScreen settingsScreen;
```

**New config event handler function (after onBleEvent, before system_task):**

```cpp
static void onConfigEvent(const ConfigEvent& evt) {
    auto* nvsMgr = NvsManager::getInstance();

    switch (evt.type) {
        case CONFIG_EVT_VOLUME: {
            ESP_LOGI(TAG, "Config BLE: volume=%d", evt.value_u8);
            // 1. Apply hardware change
            setAudioVolume(evt.value_u8);
            // 2. Persist to NVS
            nvsMgr->saveVolume(evt.value_u8);
            // 3. Notify BLE client (echo back)
            notify_config_volume();
            // 4. Update SettingsScreen UI if active
            if (screenMgr && screenMgr->getCurrentScreen() == ScreenType::SETTINGS) {
                settingsScreen.updateVolumeSlider(evt.value_u8);
            }
            break;
        }
        case CONFIG_EVT_BRIGHTNESS: {
            ESP_LOGI(TAG, "Config BLE: brightness=%d", evt.value_u8);
            bsp_display_brightness_set(evt.value_u8);
            nvsMgr->saveBrightness(evt.value_u8);
            notify_config_brightness();
            if (screenMgr && screenMgr->getCurrentScreen() == ScreenType::SETTINGS) {
                settingsScreen.updateBrightnessSlider(evt.value_u8);
            }
            break;
        }
        case CONFIG_EVT_DRIVER_NAME: {
            ESP_LOGI(TAG, "Config BLE: driver %d name='%s'", evt.driver_id, evt.name);
            nvsMgr->saveDriverName(evt.driver_id, evt.name);
            break;
        }
        case CONFIG_EVT_TIME_SYNC: {
            ESP_LOGI(TAG, "Config BLE: time sync=%lu", (unsigned long)evt.value_u32);
            struct timeval tv = {
                .tv_sec = (time_t)evt.value_u32,
                .tv_usec = 0,
            };
            settimeofday(&tv, NULL);
            break;
        }
    }
}
```

**In system_task -- SettingsScreen registration (after numpadScreen.create()):**

Add after existing screen registrations and creates:
```cpp
// Registra SettingsScreen
screenMgr->registerScreen(&settingsScreen);
settingsScreen.create();
```

Note: Do NOT call settingsScreen.setStatusBar() -- SettingsScreen does not use ButtonManager/StatusBar delegation (it creates its own widgets directly). Settings screen does not need StatusBar reference.

**In system_task -- Config event queue init (after BLE init success):**

Add inside the `if (!bleSvc->init())` else block, after the advertising log:
```cpp
// Inicializa fila de eventos de configuracao
config_event_queue_init();
```

**In system_task main loop -- Add config event processing (after ble_process_events):**

```cpp
// Processa eventos de configuracao BLE
config_process_events(onConfigEvent);
```
  </action>
  <verify>
pio run -- build succeeds.
Grep for "settingsScreen" in main.cpp (static instance declared and registered).
Grep for "config_process_events" in main.cpp (main loop consumer wired).
Grep for "onConfigEvent" in main.cpp (handler function exists).
Grep for "config_event_queue_init" in main.cpp (queue initialized).
  </verify>
  <done>
SettingsScreen statically allocated and registered with ScreenManager. Config event queue initialized after BLE init. Config events processed every 5ms in main loop: volume changes apply audio + NVS + notify BLE + update UI, brightness changes apply backlight + NVS + notify BLE + update UI, driver names persist to NVS, time sync sets system clock. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add BLE notifications to SettingsScreen sliders + SETTINGS to StatusBar menu</name>
  <files>
    src/ui/screens/settings_screen.cpp
    src/ui/widgets/status_bar.cpp
  </files>
  <action>
**Modify src/ui/screens/settings_screen.cpp:**

1. Add include at top (after existing includes):
```cpp
#include "services/ble/gatt/gatt_config.h"
```

2. In the volume slider callback (static function), after the NvsManager::getInstance()->saveVolume(value) line, add:
```cpp
notify_config_volume();
```

3. In the brightness slider callback (static function), after the NvsManager::getInstance()->saveBrightness(value) line, add:
```cpp
notify_config_brightness();
```

This is a 3-line addition (1 include + 2 notify calls). The notify functions check s_conn_handle and subscription flags internally -- safe to call even when no BLE client is connected.

**Modify src/ui/widgets/status_bar.cpp:**

Find the menu button callback. Currently it alternates between NUMPAD and JORNADA (2-way toggle). Change to a 3-way cycle that includes SETTINGS:

Replace the existing toggle logic with:
```cpp
// Ciclo de 3 telas: NUMPAD -> JORNADA -> SETTINGS -> NUMPAD
auto currentScreen = screenMgr_->getCurrentScreen();
if (currentScreen == ScreenType::NUMPAD) {
    screenMgr_->cycleTo(ScreenType::JORNADA);
} else if (currentScreen == ScreenType::JORNADA) {
    screenMgr_->cycleTo(ScreenType::SETTINGS);
} else if (currentScreen == ScreenType::SETTINGS) {
    screenMgr_->cycleTo(ScreenType::NUMPAD);
} else {
    screenMgr_->cycleTo(ScreenType::NUMPAD);  // fallback
}
```

This change preserves the existing cycleTo() mechanism (replace without push/pop) and adds SETTINGS as the third stop in the cycle.
  </action>
  <verify>
pio run -- build succeeds.
Grep for "notify_config_volume" in settings_screen.cpp (BLE notification from volume slider).
Grep for "notify_config_brightness" in settings_screen.cpp (BLE notification from brightness slider).
Grep for "SETTINGS" in status_bar.cpp (menu cycling includes settings).
Grep for "gatt_config.h" in settings_screen.cpp (include added).
  </verify>
  <done>
SettingsScreen slider callbacks trigger BLE notifications after NVS save (notify_config_volume and notify_config_brightness). Menu button in StatusBar cycles through 3 screens: NUMPAD -> JORNADA -> SETTINGS -> NUMPAD. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Route config subscribe events in ble_service.cpp</name>
  <files>
    src/services/ble/ble_service.cpp
  </files>
  <action>
**Add include (after existing gatt_journey.h include):**
```cpp
#include "services/ble/gatt/gatt_config.h"
```

**In GAP event handler -- BLE_GAP_EVENT_CONNECT (success path):**

After existing `gatt_journey_set_conn_handle(event->connect.conn_handle)`:
```cpp
gatt_config_set_conn_handle(event->connect.conn_handle);
```

**In GAP event handler -- BLE_GAP_EVENT_DISCONNECT:**

After existing `gatt_journey_set_conn_handle(0)` and `gatt_journey_reset_subscriptions()`:
```cpp
gatt_config_set_conn_handle(0);
gatt_config_reset_subscriptions();
```

**In GAP event handler -- BLE_GAP_EVENT_SUBSCRIBE:**

After existing call to `gatt_journey_update_subscription(...)`:
```cpp
// Route config characteristic subscriptions
gatt_config_update_subscription(
    event->subscribe.attr_handle,
    event->subscribe.cur_notify
);
```

Note: Both journey and config modules check if the attr_handle matches their own characteristics. If it does not match, they silently ignore it. So calling both is safe and correct.

**No other changes needed.** The existing GAP handler structure supports this modular pattern -- each GATT module registers its own subscription tracking.
  </action>
  <verify>
pio run -- build succeeds.
Grep for "gatt_config_set_conn_handle" in ble_service.cpp (CONNECT and DISCONNECT paths).
Grep for "gatt_config_update_subscription" in ble_service.cpp (SUBSCRIBE handler).
Grep for "gatt_config_reset_subscriptions" in ble_service.cpp (DISCONNECT cleanup).
  </verify>
  <done>
BLE service routes connection/subscription events to config module. On CONNECT: sets config conn_handle. On SUBSCRIBE: routes attr_handle to config module for per-characteristic tracking. On DISCONNECT: clears config conn_handle and resets all config subscriptions. Both journey and config modules coexist in the same GAP handler. Build passes.
  </done>
</task>

</tasks>

<verification>
- `pio run` succeeds with zero errors
- Full bidirectional flow works:
  - Touchscreen -> BLE: slider change -> setAudioVolume/bsp_display_brightness_set -> NVS save -> notify_config_volume/brightness
  - BLE -> Touchscreen: GATT write -> config_post_event -> queue -> onConfigEvent -> hardware apply -> NVS save -> update SettingsScreen UI
- Config events processed in main loop (config_process_events in while(1))
- BLE subscribe events routed to config module (gatt_config_update_subscription in ble_service.cpp)
- SettingsScreen accessible via menu button cycling (NUMPAD -> JORNADA -> SETTINGS)
- Driver names from BLE persisted in NVS
- Time sync from BLE sets system clock
- SettingsScreen slider callbacks send BLE notifications (notify_config_volume/brightness)
</verification>

<success_criteria>
- Build passes (pio run exits 0)
- SettingsScreen registered and accessible from menu
- Config event handler processes all 4 event types (volume, brightness, driver name, time sync)
- BLE notifications sent when user changes volume/brightness on touchscreen
- SettingsScreen sliders update when BLE client writes new values (only if screen active)
- ble_service.cpp routes subscribe events to both journey and config modules
- No feedback loops (updatingFromExternal_ flag prevents slider -> notify -> event -> slider cycle)
</success_criteria>

<output>
After completion, create `.planning/phases/03-settings/03-03-SUMMARY.md`
</output>
