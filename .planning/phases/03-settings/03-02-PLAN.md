---
phase: 03-settings
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - include/services/ble/gatt/gatt_config.h
  - src/services/ble/gatt/gatt_config.cpp
  - include/config/ble_uuids.h
  - include/services/ble/gatt/gatt_server.h
  - src/services/ble/gatt/gatt_server.cpp
autonomous: true

must_haves:
  truths:
    - "GATT Configuration Service with 4 characteristics is registered in the GATT table"
    - "Volume characteristic (read+write+notify) validates 0-21 range and posts config event on write"
    - "Brightness characteristic (read+write+notify) validates 0-100 range and posts config event on write"
    - "Driver Name characteristic (read+write) accepts 1-byte driver_id + up to 32 bytes name with null-termination safety"
    - "Time Sync characteristic (write-only) accepts 4-byte little-endian Unix timestamp and posts config event"
    - "Config event queue bridges GATT writes to Core 0 system_task safely"
  artifacts:
    - path: "include/services/ble/gatt/gatt_config.h"
      provides: "Configuration Service header with packed structs, access callbacks, notification functions, config event queue API"
      contains: "ConfigEventType"
    - path: "src/services/ble/gatt/gatt_config.cpp"
      provides: "GATT access callbacks with validation, config event queue implementation, notification functions"
      min_lines: 150
    - path: "include/config/ble_uuids.h"
      provides: "Configuration Service UUIDs (group 2)"
      contains: "BLE_UUID_CONFIG_SVC"
    - path: "src/services/ble/gatt/gatt_server.cpp"
      provides: "Configuration Service added to GATT service table"
      contains: "BLE_UUID_CONFIG_SVC"
  key_links:
    - from: "src/services/ble/gatt/gatt_config.cpp"
      to: "gatt_validation.h"
      via: "gatt_validate_write() and gatt_read_write_data() for all writable characteristics"
      pattern: "gatt_validate_write"
    - from: "src/services/ble/gatt/gatt_config.cpp"
      to: "config_event_queue"
      via: "config_post_event() from GATT write callbacks for Core 0 processing"
      pattern: "config_post_event"
    - from: "src/services/ble/gatt/gatt_server.cpp"
      to: "gatt_config.h"
      via: "Access callbacks and val_handles referenced in GATT table"
      pattern: "config_volume_access"
---

<objective>
Create the GATT Configuration Service with volume, brightness, driver name, and time sync characteristics, plus a config event queue for thread-safe BLE-to-UI communication.

Purpose: This plan builds the BLE backend for configuration. It follows the exact same module pattern as gatt_journey.h/.cpp (packed structs, C linkage callbacks, subscription tracking, notify functions). The config event queue extends the proven BLE event queue pattern to carry configuration change events from GATT write callbacks to the Core 0 system_task where LVGL and NVS operations are safe. Plan 03-03 wires the queue consumer into main.cpp.

Output: GATT Configuration Service module, config event queue, Configuration Service UUIDs, updated GATT server table.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/02-ble-core/02-02-SUMMARY.md
@.planning/phases/02-ble-core/02-04-SUMMARY.md
@.planning/phases/03-settings/03-RESEARCH.md

@include/services/ble/gatt/gatt_journey.h
@src/services/ble/gatt/gatt_journey.cpp
@include/services/ble/gatt/gatt_validation.h
@include/services/ble/gatt/gatt_server.h
@src/services/ble/gatt/gatt_server.cpp
@include/services/ble/ble_event_queue.h
@src/services/ble/ble_event_queue.cpp
@include/config/ble_uuids.h
@include/config/app_config.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: GATT Configuration Service module + config event queue</name>
  <files>
    include/services/ble/gatt/gatt_config.h
    src/services/ble/gatt/gatt_config.cpp
    include/config/ble_uuids.h
  </files>
  <action>
**ble_uuids.h additions (new section after Diagnostics, before #endif):**

Add Configuration Service UUIDs (group 2) following the exact same UUID base pattern:

```
UUID base: 0000XXXX-4A47-0000-4763-7365-00000002

Service:     00000200-4A47-0000-4763-7365-00000002
Volume:      00000201-4A47-0000-4763-7365-00000002
Brightness:  00000202-4A47-0000-4763-7365-00000002
Driver Name: 00000203-4A47-0000-4763-7365-00000002
Time Sync:   00000204-4A47-0000-4763-7365-00000002
```

Convert to little-endian BLE_UUID128_INIT bytes following the existing pattern. The last byte group (Y) changes from 01/03 to 02.

Static const ble_uuid128_t variables:
- BLE_UUID_CONFIG_SVC
- BLE_UUID_CONFIG_VOLUME_CHR
- BLE_UUID_CONFIG_BRIGHTNESS_CHR
- BLE_UUID_CONFIG_DRIVER_NAME_CHR
- BLE_UUID_CONFIG_TIME_SYNC_CHR

**gatt_config.h (follow gatt_journey.h pattern exactly):**

Includes: stdint.h, stddef.h, stdbool.h. Forward declare struct ble_gatt_access_ctxt. Use extern "C" linkage guards.

Define BLE_ATT_ERR_VALUE_NOT_ALLOWED as 0x13 (if not already defined by NimBLE).

Config event types enum:
```cpp
enum ConfigEventType : uint8_t {
    CONFIG_EVT_VOLUME = 0,
    CONFIG_EVT_BRIGHTNESS,
    CONFIG_EVT_DRIVER_NAME,
    CONFIG_EVT_TIME_SYNC,
};
```

Config event struct:
```cpp
struct ConfigEvent {
    ConfigEventType type;
    uint8_t driver_id;       // For driver name events (0-2)
    uint8_t value_u8;        // For volume/brightness
    uint32_t value_u32;      // For time sync (unix timestamp)
    char name[32];           // For driver name (null-terminated)
};
```

Config event queue API (same pattern as ble_event_queue):
- `bool config_event_queue_init(void);`
- `void config_post_event(ConfigEventType type, uint8_t value_u8);` -- for volume/brightness
- `void config_post_event_driver(uint8_t driver_id, const char* name);` -- for driver names
- `void config_post_event_time(uint32_t timestamp);` -- for time sync
- `bool config_process_events(void (*handler)(const ConfigEvent& evt));` -- called from main loop

GATT access callback declarations:
- `int config_volume_access(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt* ctxt, void* arg);`
- `int config_brightness_access(...)` same signature
- `int config_driver_name_access(...)` same signature
- `int config_time_sync_access(...)` same signature

Notification functions:
- `void notify_config_volume(void);`
- `void notify_config_brightness(void);`

Subscription and connection management:
- `void gatt_config_set_conn_handle(uint16_t handle);`
- `void gatt_config_update_subscription(uint16_t attr_handle, bool notify);`
- `void gatt_config_reset_subscriptions(void);`

Read accessors (for GATT read operations -- return current cached value):
- `uint8_t config_get_current_volume(void);`
- `uint8_t config_get_current_brightness(void);`

**gatt_config.cpp:**

LOG_TAG("GATT_CONFIG")

Include: gatt_config.h, gatt_validation.h, config/app_config.h, config/ble_uuids.h, services/nvs/nvs_manager.h, simple_audio_manager.h, esp_bsp.h, host/ble_hs.h, host/ble_gatt.h, os/os_mbuf.h, freertos/FreeRTOS.h, freertos/queue.h, esp_log.h, string.h, sys/time.h

**Static state (same pattern as gatt_journey.cpp):**
- static uint16_t s_conn_handle = 0;
- static bool s_volume_notify_enabled = false;
- static bool s_brightness_notify_enabled = false;
- static QueueHandle_t s_config_queue = NULL;

**Config event queue (follow ble_event_queue.cpp pattern):**
- config_event_queue_init(): xQueueCreate(8, sizeof(ConfigEvent))
- config_post_event(): build ConfigEvent, xQueueSend with zero timeout
- config_post_event_driver(): build ConfigEvent with driver_id and name, ensure null termination
- config_post_event_time(): build ConfigEvent with timestamp
- config_process_events(): loop xQueueReceive with zero timeout, call handler

**config_get_current_volume() / config_get_current_brightness():**
- Read from NvsManager::getInstance()->loadVolume(AUDIO_VOLUME_DEFAULT) / loadBrightness(100)
- Note: these are called from GATT read callbacks which may run on NimBLE task. NvsManager has mutex protection, so this is safe.

**config_volume_access():**
- READ: get current volume via config_get_current_volume(), os_mbuf_append 1 byte
- WRITE: gatt_validate_write(ctxt, 1, 1), gatt_read_write_data into 1-byte buffer, bounds check buf[0] > AUDIO_VOLUME_MAX -> return 0x13 (BLE_ATT_ERR_VALUE_NOT_ALLOWED), config_post_event(CONFIG_EVT_VOLUME, buf[0])

**config_brightness_access():**
- Same pattern as volume but range 0-100

**config_driver_name_access():**
- READ: For read, return all 3 driver names packed. Build a buffer: for each driver 0-2, write driver_id (1 byte) then name (32 bytes, null-padded). Total: 3 * 33 = 99 bytes. Use NvsManager::getInstance()->loadDriverName() for each. If name not set, write empty string (just null byte + padding).
- WRITE: gatt_validate_write(ctxt, 2, 33) -- minimum 2 bytes (id + at least 1 char), max 33 bytes (id + 32 name). Extract driver_id = buf[0] - 1 (BLE uses 1-3, NVS uses 0-2). Validate driver_id range. Copy name bytes to a 33-byte local buffer, force null termination: name_buf[received_len - 1] = '\0' (per Pitfall 6). Post config_post_event_driver(driver_id, name_buf).

**config_time_sync_access():**
- WRITE-ONLY: No read support. If READ, return BLE_ATT_ERR_READ_NOT_PERMITTED.
- WRITE: gatt_validate_write(ctxt, 4, 4), extract 4-byte little-endian uint32_t, validate > 0, config_post_event_time(timestamp).

**Notification functions (follow gatt_journey.cpp notify pattern):**
- notify_config_volume(): Check s_conn_handle != 0 && s_volume_notify_enabled. Get current volume. Build os_mbuf with 1 byte. ble_gatts_notify_custom(s_conn_handle, gatt_config_volume_val_handle, om).
- notify_config_brightness(): Same pattern.

**Subscription management (follow gatt_journey.cpp pattern):**
- gatt_config_set_conn_handle(handle): set s_conn_handle
- gatt_config_update_subscription(attr_handle, notify): compare attr_handle against gatt_config_volume_val_handle and gatt_config_brightness_val_handle, update corresponding flag
- gatt_config_reset_subscriptions(): reset both flags

**IMPORTANT C++ notes from Phase 2 decisions:**
- Use extern "C" { } for all function implementations since gatt_config.h has C linkage
- Field order in any designated initializers must match struct declaration order
  </action>
  <verify>
pio run -- build succeeds with zero errors.
Grep for "BLE_UUID_CONFIG_SVC" in ble_uuids.h.
Grep for "config_volume_access" in gatt_config.h.
Grep for "config_event_queue_init" in gatt_config.h and gatt_config.cpp.
Grep for "gatt_validate_write" in gatt_config.cpp (confirms validation utility usage).
Grep for "CONFIG_EVT_VOLUME" in gatt_config.h (enum exists).
  </verify>
  <done>
GATT Configuration Service module complete with 4 characteristics (volume, brightness, driver name, time sync). Config event queue (FreeRTOS, 8 items) bridges GATT writes to Core 0. Write validation uses existing gatt_validation.h. Volume/brightness have read+write+notify. Driver name has read+write. Time sync is write-only. Out-of-range values rejected with ATT error 0x13. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Configuration Service in GATT server table</name>
  <files>
    include/services/ble/gatt/gatt_server.h
    src/services/ble/gatt/gatt_server.cpp
  </files>
  <action>
**gatt_server.h additions:**
Add val_handle exports for Configuration Service characteristics (after existing gatt_ignition_val_handle):
```cpp
extern uint16_t gatt_config_volume_val_handle;
extern uint16_t gatt_config_brightness_val_handle;
```
Note: Driver Name and Time Sync do not need val_handles (no notifications on those).

**gatt_server.cpp modifications:**

1. Add include: `#include "services/ble/gatt/gatt_config.h"`

2. Add val_handle definitions (after existing ones):
```cpp
uint16_t gatt_config_volume_val_handle = 0;
uint16_t gatt_config_brightness_val_handle = 0;
```

3. Add Configuration Service to gatt_svr_svcs[] array BEFORE the { 0 } terminator (after Diagnostics Service):

```cpp
// Configuration Service (custom UUID)
{
    .type = BLE_GATT_SVC_TYPE_PRIMARY,
    .uuid = &BLE_UUID_CONFIG_SVC.u,
    .characteristics = (struct ble_gatt_chr_def[]) {
        // Volume: read + write + notify
        {
            .uuid = &BLE_UUID_CONFIG_VOLUME_CHR.u,
            .access_cb = config_volume_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_WRITE | BLE_GATT_CHR_F_NOTIFY,
            .min_key_size = 0,
            .val_handle = &gatt_config_volume_val_handle,
        },
        // Brightness: read + write + notify
        {
            .uuid = &BLE_UUID_CONFIG_BRIGHTNESS_CHR.u,
            .access_cb = config_brightness_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_WRITE | BLE_GATT_CHR_F_NOTIFY,
            .min_key_size = 0,
            .val_handle = &gatt_config_brightness_val_handle,
        },
        // Driver Name: read + write (no notify)
        {
            .uuid = &BLE_UUID_CONFIG_DRIVER_NAME_CHR.u,
            .access_cb = config_driver_name_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_WRITE,
            .min_key_size = 0,
            .val_handle = NULL,
        },
        // Time Sync: write only
        {
            .uuid = &BLE_UUID_CONFIG_TIME_SYNC_CHR.u,
            .access_cb = config_time_sync_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_WRITE,
            .min_key_size = 0,
            .val_handle = NULL,
        },
        { 0 }, // Terminador de caracteristicas
    },
},
```

**CRITICAL:** Field order MUST match struct declaration: uuid, access_cb, arg, descriptors, flags, min_key_size, val_handle (per Phase 02-02 decision).

4. Update ESP_LOGI in gatt_svr_init(): "GATT server inicializado: DIS + Journey (2 chr) + Diagnostics (1 chr) + Config (4 chr)"
  </action>
  <verify>
pio run -- build succeeds.
Grep for "gatt_config_volume_val_handle" in gatt_server.h and gatt_server.cpp.
Grep for "BLE_UUID_CONFIG_SVC" in gatt_server.cpp (service registered).
Grep for "config_volume_access" in gatt_server.cpp (callback wired).
Grep for "Config (4 chr)" in gatt_server.cpp (log message updated).
  </verify>
  <done>
Configuration Service with 4 characteristics registered in GATT server table. Volume and brightness have val_handles for notification support. Driver name and time sync have no val_handles (no notifications needed). GATT init log reflects new service. Build passes with all characteristics discoverable by BLE scanner.
  </done>
</task>

</tasks>

<verification>
- `pio run` succeeds with zero errors
- 5 new Configuration Service UUIDs in ble_uuids.h (service + 4 characteristics)
- gatt_config.h declares 4 access callbacks, 2 notify functions, config event queue API
- gatt_config.cpp implements all callbacks with proper validation (gatt_validate_write + bounds check)
- gatt_server.cpp has Configuration Service in GATT table with correct field order
- gatt_server.h exports 2 new val_handles (volume, brightness)
- Config event queue initialized with FreeRTOS queue (8 items)
</verification>

<success_criteria>
- Build passes (pio run exits 0)
- GATT Configuration Service has 4 characteristics in server table
- Write validation rejects out-of-range values (volume > 21 returns 0x13, brightness > 100 returns 0x13)
- Config event queue API matches ble_event_queue pattern
- All code follows project conventions (extern C, designated initializer order, LOG_TAG)
- Driver name write ensures null termination for UTF-8 safety
</success_criteria>

<output>
After completion, create `.planning/phases/03-settings/03-02-SUMMARY.md`
</output>
