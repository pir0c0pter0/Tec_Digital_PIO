---
phase: 02-ble-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sdkconfig.defaults
  - include/config/app_config.h
  - include/interfaces/i_ble.h
  - include/config/ble_uuids.h
  - include/services/ble/ble_service.h
  - src/services/ble/ble_service.cpp
  - src/main.cpp
autonomous: true

must_haves:
  truths:
    - "Firmware builds successfully with NimBLE enabled"
    - "Device advertises as GS-Jornada-XXXX (last 4 hex MAC) visible in nRF Connect"
    - "Device pairs using LE Secure Connections (Just Works) and encrypts the link"
    - "Bond is persisted in NVS -- device reconnects without re-pairing after power cycle"
  artifacts:
    - path: "sdkconfig.defaults"
      provides: "NimBLE sdkconfig flags"
      contains: "CONFIG_BT_NIMBLE_ENABLED=y"
    - path: "include/interfaces/i_ble.h"
      provides: "Abstract BLE service interface"
      contains: "class IBleService"
    - path: "include/config/ble_uuids.h"
      provides: "All custom BLE UUIDs centralized"
      contains: "BLE_UUID128_INIT"
    - path: "src/services/ble/ble_service.cpp"
      provides: "NimBLE init, GAP advertising, security, bonding"
      min_lines: 150
  key_links:
    - from: "src/main.cpp"
      to: "src/services/ble/ble_service.cpp"
      via: "BleService::getInstance()->init() call in system_task"
      pattern: "BleService.*init"
    - from: "src/services/ble/ble_service.cpp"
      to: "sdkconfig.defaults"
      via: "NimBLE enabled via CONFIG_BT_NIMBLE_ENABLED"
      pattern: "nimble_port_init"
    - from: "src/main.cpp"
      to: "nvs_flash.h"
      via: "nvs_flash_init() call before NimBLE init"
      pattern: "nvs_flash_init\\(\\)"
---

<objective>
Initialize the NimBLE BLE stack on the ESP32-S3 with GAP advertising, LE Secure Connections, and bond persistence.

Purpose: This is the BLE foundation -- nothing in Phase 2 works without a running NimBLE stack that advertises, pairs securely, and persists bonds. This plan delivers a device that is visible in nRF Connect, pairs with a phone, and remembers the bond across reboots.

Output: BLE service files, sdkconfig with NimBLE flags, device advertising as "GS-Jornada-XXXX" with security and bonding.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ble-core/02-RESEARCH.md

Key codebase files to read before implementing:
@sdkconfig.defaults
@include/config/app_config.h
@src/main.cpp
@partitions.csv
@include/interfaces/i_ignicao.h (pattern reference for new interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: sdkconfig NimBLE flags + BLE constants + IBleService interface + UUIDs header</name>
  <files>
    sdkconfig.defaults
    include/config/app_config.h
    include/interfaces/i_ble.h
    include/config/ble_uuids.h
  </files>
  <action>
    1. **sdkconfig.defaults** -- Append the BLE/NimBLE section (from research Pattern 1). Add ALL these flags:

    ```
    # ============================================================================
    # BLE / NimBLE
    # ============================================================================
    CONFIG_BT_ENABLED=y
    CONFIG_BT_NIMBLE_ENABLED=y
    CONFIG_BT_NIMBLE_ROLE_PERIPHERAL=y
    CONFIG_BT_NIMBLE_ROLE_BROADCASTER=y
    CONFIG_BT_NIMBLE_ROLE_CENTRAL=n
    CONFIG_BT_NIMBLE_ROLE_OBSERVER=n
    CONFIG_BT_NIMBLE_MAX_CONNECTIONS=1
    CONFIG_BT_NIMBLE_SM_LEGACY=n
    CONFIG_BT_NIMBLE_SM_SC=y
    CONFIG_BT_NIMBLE_NVS_PERSIST=y
    CONFIG_BT_NIMBLE_MAX_BONDS=3
    CONFIG_BT_NIMBLE_PINNED_TO_CORE_0=y
    CONFIG_BT_NIMBLE_HOST_TASK_STACK_SIZE=4096
    CONFIG_BT_NIMBLE_ATT_PREFERRED_MTU=512
    CONFIG_BT_NIMBLE_MSYS_1_BLOCK_COUNT=12
    CONFIG_BT_NIMBLE_MSYS_1_BLOCK_SIZE=256
    CONFIG_BT_NIMBLE_MSYS_2_BLOCK_COUNT=24
    CONFIG_BT_NIMBLE_MSYS_2_BLOCK_SIZE=320
    CONFIG_BT_NIMBLE_LOG_LEVEL_WARNING=y
    CONFIG_BT_NIMBLE_EXT_ADV=n
    CONFIG_BT_NIMBLE_50_FEATURE_SUPPORT=n
    ```

    This covers: INFRA-02 (sdkconfig NimBLE flags) and part of INFRA-03 (OTA rollback already in sdkconfig from Phase 1).

    2. **include/config/app_config.h** -- Update the BLE section. The existing placeholders have BLE_MTU_PREFERRED=256 but research says 512. Update:
    - `BLE_MTU_PREFERRED` from 256 to 512
    - Add `BLE_MAX_CONNECTIONS 1`
    - Add `BLE_ADV_INTERVAL_MIN 0x0020` (20ms * 0.625 = 12.5ms, fast advertising)
    - Add `BLE_ADV_INTERVAL_MAX 0x0040` (40ms * 0.625 = 25ms)
    - Add `BLE_PROTOCOL_VERSION "BLE-P1.0"` (for BLE-08, used later in DIS)
    - Add `BLE_NOTIFICATION_MIN_INTERVAL_MS 100` (rate limiting)
    Keep existing constants (BLE_DEVICE_NAME_PREFIX, BLE_TASK_CORE, etc.).

    3. **include/interfaces/i_ble.h** -- Create abstract BLE service interface. Follow the i_ignicao.h pattern:
    - File header with section separators (Portuguese comments)
    - `#ifndef I_BLE_H / #define I_BLE_H`
    - `#ifdef __cplusplus`
    - `enum class BleStatus : uint8_t { DISCONNECTED = 0, ADVERTISING, CONNECTED, SECURED }`
    - `typedef void (*BleStatusCallback)(BleStatus newStatus)` callback type
    - `class IBleService` with pure virtual methods:
      - `virtual bool init() = 0`
      - `virtual void startAdvertising() = 0`
      - `virtual void stopAdvertising() = 0`
      - `virtual BleStatus getStatus() const = 0`
      - `virtual uint16_t getConnHandle() const = 0`
      - `virtual uint16_t getCurrentMtu() const = 0`
      - `virtual void setStatusCallback(BleStatusCallback callback) = 0`
      - `virtual ~IBleService() = default`
    - No extern "C" section needed (BLE is C++ only)

    4. **include/config/ble_uuids.h** -- Create centralized UUID header for all custom BLE UUIDs. This avoids scattering UUIDs across files:
    - File header with section separators
    - `#ifndef BLE_UUIDS_H / #define BLE_UUIDS_H`
    - Include `host/ble_uuid.h`
    - Define base UUID format: `0000XXXX-4a47-0000-4763-7365-0000000Y` where XXXX is short ID and Y is service group
    - Journey Service UUID (group 1): `00000100-4a47-0000-4763-7365-00000001`
    - Journey State characteristic: `00000101-...01`
    - Ignition Status characteristic: `00000102-...01`
    - Diagnostics Service UUID (group 3): `00000300-4a47-0000-4763-7365-00000003`
    - System Diagnostics characteristic: `00000301-...03`
    - Declare each as `static const ble_uuid128_t` using `BLE_UUID128_INIT(...)` macro
    - IMPORTANT: BLE_UUID128_INIT takes bytes in LITTLE-ENDIAN order (reversed from the UUID string)
  </action>
  <verify>
    Run `pio run` -- must compile without errors. The NimBLE headers should resolve when BT_ENABLED is set. If build fails on NimBLE includes, verify sdkconfig flags are being picked up (may need `pio run --target clean` first after sdkconfig changes).
  </verify>
  <done>
    sdkconfig.defaults has all NimBLE flags, app_config.h has updated BLE constants, i_ble.h defines IBleService interface with BleStatus enum, ble_uuids.h has all custom UUIDs. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: BLE service implementation (NimBLE init + GAP + security + bonding) + main.cpp integration</name>
  <files>
    include/services/ble/ble_service.h
    src/services/ble/ble_service.cpp
    src/main.cpp
  </files>
  <action>
    1. **include/services/ble/ble_service.h** -- Concrete BLE service header:
    - Include `interfaces/i_ble.h`, FreeRTOS headers
    - `class BleService : public IBleService` with:
      - `static BleService* getInstance()` (singleton pattern per codebase convention)
      - All IBleService pure virtual methods implemented
      - Private members: `static BleService* instance_`, `BleStatus status_`, `uint16_t connHandle_`, `uint16_t currentMtu_`, `BleStatusCallback statusCallback_`, `SemaphoreHandle_t mutex_`, `bool initialized_`
      - Private static methods for NimBLE callbacks: `static int gapEventHandler(struct ble_gap_event* event, void* arg)`, `static void onBleSync()`, `static void onBleReset(int reason)`, `static void bleHostTask(void* param)`
      - Private: `void startAdvertisingInternal()` (called from sync callback)

    2. **src/services/ble/ble_service.cpp** -- Full NimBLE implementation following research Pattern 1:

    **Includes:** NimBLE headers (`nimble/nimble_port.h`, `nimble/nimble_port_freertos.h`, `host/ble_hs.h`, `host/ble_gap.h`, `host/util/util.h`, `services/gap/ble_svc_gap.h`, `services/gatt/ble_svc_gatt.h`), ESP BT controller (`esp_bt.h`), NVS flash, MAC address (`esp_mac.h`), app_config.h, debug_utils.h.

    **LOG_TAG:** `"BLE_SVC"`

    **init() method** -- Execute in order:
    a. Create mutex
    b. Call `nvs_flash_init()` for default NVS partition (CRITICAL for bond persistence -- see research Pitfall 1). Handle `ESP_ERR_NVS_NO_FREE_PAGES` with erase+reinit.
    c. Init BT controller: `esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT()`, `esp_bt_controller_init(&bt_cfg)`, `esp_bt_controller_enable(ESP_BT_MODE_BLE)`
    d. `nimble_port_init()`
    e. Configure host callbacks: `ble_hs_cfg.reset_cb = onBleReset`, `ble_hs_cfg.sync_cb = onBleSync`, `ble_hs_cfg.store_status_cb = ble_store_util_status_rr`
    f. Configure security: `ble_hs_cfg.sm_io_cap = BLE_HS_IO_NO_INPUT_OUTPUT`, `sm_bonding = 1`, `sm_sc = 1` (LE Secure Connections), `sm_mitm = 0` (Just Works), key distribution for ENC+ID
    g. Init GAP and GATT built-in services: `ble_svc_gap_init()`, `ble_svc_gatt_init()`
    h. Build device name: read BT MAC with `esp_read_mac(mac, ESP_MAC_BT)`, format as `"GS-Jornada-XXYY"` using last 2 bytes, call `ble_svc_gap_device_name_set()`
    i. Init bond store: `ble_store_config_init()`
    j. Set preferred MTU: `ble_att_set_preferred_mtu(BLE_MTU_PREFERRED)`
    k. Start NimBLE host task: `nimble_port_freertos_init(bleHostTask)`
    l. Set status to ADVERTISING, log success

    **onBleSync() static callback** -- Called when NimBLE host is synced:
    a. `ble_hs_id_infer_auto(0, &own_addr_type)` to get address type
    b. Call `getInstance()->startAdvertisingInternal()`

    **startAdvertisingInternal()** -- GAP advertising setup (research Pattern 6):
    a. Build adv fields: flags (DISC_GEN | BREDR_UNSUP), name (complete), tx power level
    b. Build scan response fields: include custom service UUIDs (128-bit Journey + Diagnostics). This avoids exceeding 31-byte adv data limit (research Pitfall 5).
    c. Set adv params: `conn_mode = BLE_GAP_CONN_MODE_UND`, `disc_mode = BLE_GAP_DISC_MODE_GEN`
    d. Start advertising with `ble_gap_adv_start(own_addr_type, NULL, BLE_HS_FOREVER, &adv_params, gapEventHandler, NULL)`
    e. Update status to ADVERTISING, post to callback

    **gapEventHandler() static callback** -- Handle GAP events (research Pattern from GAP Event Handler):
    - `BLE_GAP_EVENT_CONNECT`: If status==0, save conn_handle, update status to CONNECTED, initiate security with `ble_gap_security_initiate()`. If failed, restart advertising.
    - `BLE_GAP_EVENT_DISCONNECT`: Reset conn_handle, reset notify flags, update status to DISCONNECTED, restart advertising.
    - `BLE_GAP_EVENT_ENC_CHANGE`: If status==0, update status to SECURED.
    - `BLE_GAP_EVENT_MTU`: Log new MTU, save `currentMtu_`, call `ble_hs_hci_util_set_data_len()` for max throughput.
    - `BLE_GAP_EVENT_REPEAT_PAIRING`: Delete old bond, return `BLE_GAP_REPEAT_PAIRING_RETRY`.
    - `BLE_GAP_EVENT_SUBSCRIBE`: Log subscription changes (will be wired to GATT in plan 02-02).

    All status changes should: update `status_` member, call `statusCallback_` if registered.

    **Thread safety:** Use mutex for status reads. Callbacks execute in NimBLE host context -- keep them fast, no blocking.

    3. **src/main.cpp** -- Add BLE initialization:
    a. Add include: `#include "services/ble/ble_service.h"`
    b. In `system_task()`, BEFORE existing `NvsManager::getInstance()->init()` call, add `nvs_flash_init()` for default partition. Actually, BleService::init() handles this internally. So just call it after NVS manager init.
    c. After `systemInitialized = true` line, add:
       ```cpp
       // Inicializa BLE
       auto* bleSvc = BleService::getInstance();
       if (!bleSvc->init()) {
           ESP_LOGE(TAG, "Falha ao inicializar BLE!");
       } else {
           ESP_LOGI(TAG, "BLE inicializado - advertising...");
       }
       ```
    d. IMPORTANT: BLE init must be AFTER NvsManager init (NvsManager inits nvs_data partition, BleService inits default nvs partition).
  </action>
  <verify>
    1. `pio run` -- builds without errors or warnings related to BLE code
    2. Flash to device: `pio run --target upload`
    3. Check serial output: should see "BLE inicializado - advertising..." and NimBLE sync messages
    4. Open nRF Connect on phone: device should appear as "GS-Jornada-XXYY"
    5. Pair from nRF Connect: should pair successfully with LE Secure Connections
  </verify>
  <done>
    Device advertises as "GS-Jornada-XXXX" visible in BLE scanner. Pairs using LE Secure Connections. Bond persists across power cycles (auto-reconnect without re-pairing). All existing v1.x functionality (journey buttons, audio, ignition) works unchanged.
  </done>
</task>

</tasks>

<verification>
1. `pio run` compiles without errors
2. Device visible as "GS-Jornada-XXYY" in nRF Connect
3. Pairing succeeds with LE Secure Connections
4. After reboot, device reconnects without re-pairing
5. UI, audio, and ignition monitoring still function correctly
</verification>

<success_criteria>
- NimBLE stack is running as GATT server peripheral
- Device advertises with dynamic name based on MAC address
- LE Secure Connections pairing works (Just Works, AES-CCM encryption)
- Bonds persist in default NVS partition across power cycles
- No impact on existing UI/audio/ignition functionality
- IBleService interface and BLE UUID header established for subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/02-ble-core/02-01-SUMMARY.md`
</output>
