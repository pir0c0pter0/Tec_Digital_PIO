---
phase: 02-ble-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - include/services/ble/gatt/gatt_server.h
  - src/services/ble/gatt/gatt_server.cpp
  - include/services/ble/gatt/gatt_journey.h
  - src/services/ble/gatt/gatt_journey.cpp
  - include/services/ble/gatt/gatt_diagnostics.h
  - src/services/ble/gatt/gatt_diagnostics.cpp
  - src/services/ble/ble_service.cpp
autonomous: true

must_haves:
  truths:
    - "nRF Connect shows Device Information Service (0x180A) with manufacturer, model, firmware, hardware, and protocol version"
    - "nRF Connect shows Journey Service with journey state and ignition characteristics (read returns valid data)"
    - "nRF Connect shows Diagnostics Service with system diagnostics characteristic (read returns heap/uptime)"
    - "Journey state characteristic returns 24 bytes (3 motorists * 8 bytes packed struct)"
    - "Ignition characteristic returns 8 bytes (status + duration)"
  artifacts:
    - path: "src/services/ble/gatt/gatt_server.cpp"
      provides: "GATT service table registration and init"
      contains: "ble_gatts_count_cfg"
    - path: "src/services/ble/gatt/gatt_journey.cpp"
      provides: "Journey + ignition characteristic access callbacks and data packing"
      contains: "pack_journey_states"
    - path: "src/services/ble/gatt/gatt_diagnostics.cpp"
      provides: "Diagnostics characteristic with heap, uptime, queue depth"
      contains: "heap_caps_get_free_size"
  key_links:
    - from: "src/services/ble/gatt/gatt_server.cpp"
      to: "include/config/ble_uuids.h"
      via: "Service table references centralized UUIDs"
      pattern: "journey_svc_uuid"
    - from: "src/services/ble/gatt/gatt_journey.cpp"
      to: "interfaces/i_jornada.h"
      via: "Reads JornadaService for state packing"
      pattern: "getMotorista"
    - from: "src/services/ble/ble_service.cpp"
      to: "src/services/ble/gatt/gatt_server.cpp"
      via: "gatt_svr_init() called during NimBLE init"
      pattern: "gatt_svr_init"
---

<objective>
Create all three GATT services: Device Information (SIG 0x180A), Journey Service (custom), and Diagnostics Service (custom) -- with read and notify support on relevant characteristics.

Purpose: GATT services are the data layer of BLE -- they define what a connected mobile app can read and subscribe to. This plan delivers readable journey states, ignition status, device info, and diagnostics over BLE.

Output: GATT service table, access callbacks for read/notify, binary data packing functions, Device Info Service with protocol version.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ble-core/02-RESEARCH.md
@.planning/phases/02-ble-core/02-01-SUMMARY.md

Key codebase files to read:
@include/config/ble_uuids.h (UUIDs from plan 02-01)
@include/interfaces/i_jornada.h (DadosMotorista struct, JornadaService API)
@include/interfaces/i_ignicao.h (IgnicaoStats, getStatus API)
@src/services/ble/ble_service.cpp (NimBLE init sequence -- gatt_svr_init() call point)
@include/config/app_config.h (MAX_MOTORISTAS, APP_VERSION_STRING, APP_COMPANY, BLE_PROTOCOL_VERSION)
</context>

<tasks>

<task type="auto">
  <name>Task 1: GATT server table + DIS + Journey + Diagnostics service definitions</name>
  <files>
    include/services/ble/gatt/gatt_server.h
    src/services/ble/gatt/gatt_server.cpp
    include/services/ble/gatt/gatt_journey.h
    src/services/ble/gatt/gatt_journey.cpp
    include/services/ble/gatt/gatt_diagnostics.h
    src/services/ble/gatt/gatt_diagnostics.cpp
  </files>
  <action>
    **gatt_server.h / gatt_server.cpp** -- Central GATT service registration:

    Header:
    - `int gatt_svr_init(void)` -- Called during NimBLE init to register all services
    - `extern uint16_t journey_state_val_handle` -- Value handle for journey state notifications
    - `extern uint16_t ignition_val_handle` -- Value handle for ignition notifications

    Implementation:
    - Include ble_uuids.h, gatt_journey.h, gatt_diagnostics.h, ble_svc_gap/gatt headers
    - Try to include `services/dis/ble_svc_dis.h` for built-in Device Information Service. If it fails to compile, implement DIS as a custom service with 5 read-only string characteristics (0x2A29 manufacturer, 0x2A24 model, 0x2A26 firmware, 0x2A27 hardware, 0x2A28 software/protocol version).
    - Define `static uint16_t journey_state_val_handle` and `ignition_val_handle` for notification tracking
    - Define GATT service table `static const struct ble_gatt_svc_def gatt_svr_svcs[]`:
      - **Journey Service** (custom UUID from ble_uuids.h):
        - Journey State characteristic: UUID from ble_uuids.h, `BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_NOTIFY`, `access_cb = journey_state_access`, `val_handle = &journey_state_val_handle`
        - Ignition Status characteristic: UUID from ble_uuids.h, `BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_NOTIFY`, `access_cb = ignition_status_access`, `val_handle = &ignition_val_handle`
      - **Diagnostics Service** (custom UUID from ble_uuids.h):
        - System Diagnostics characteristic: UUID from ble_uuids.h, `BLE_GATT_CHR_F_READ` only (no notify -- diagnostics are polled), `access_cb = diagnostics_access`
      - Terminator `{ 0 }`

    `gatt_svr_init()`:
    a. `ble_svc_gap_init()`, `ble_svc_gatt_init()`
    b. Configure DIS: call `ble_svc_dis_init()` and set fields (manufacturer=APP_COMPANY, model="GS-Jornada", firmware=APP_VERSION_STRING, hardware="ESP32-S3-R8", software=BLE_PROTOCOL_VERSION). If ble_svc_dis not available, add DIS characteristics to the custom service table instead.
    c. `ble_gatts_count_cfg(gatt_svr_svcs)` -- count attributes
    d. `ble_gatts_add_svcs(gatt_svr_svcs)` -- register services
    e. Return 0 on success

    **gatt_journey.h / gatt_journey.cpp** -- Journey and ignition data:

    Header:
    - `struct __attribute__((packed)) JourneyStateData` (research format): motorist_id (u8), state (u8), active (u8), reserved (u8), time_in_state (u32) = 8 bytes per motorist
    - `struct __attribute__((packed)) IgnitionData`: status (u8), reserved[3] (u8), duration_ms (u32) = 8 bytes
    - `int journey_state_access(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)`
    - `int ignition_status_access(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)`
    - `int pack_journey_states(uint8_t* buf, size_t buf_len)` -- Returns bytes written
    - `int pack_ignition_data(uint8_t* buf, size_t buf_len)` -- Returns bytes written

    Implementation:
    - Include i_jornada.h, ignicao_control.h (for getIgnicaoStatus), time_utils.h, os/os_mbuf.h
    - LOG_TAG: `"GATT_JOURNEY"`

    `pack_journey_states()`:
    - Get JornadaService singleton, iterate motorists 1..MAX_MOTORISTAS
    - For each: call `getMotorista(id, &dados)`, pack into JourneyStateData struct
    - If getMotorista fails, fill with zeros (motorist_id set, rest zero)
    - Return `sizeof(JourneyStateData) * MAX_MOTORISTAS` (24 bytes)

    `pack_ignition_data()`:
    - Get ignition status via `getIgnicaoStatus()` (C API from ignicao_control.h)
    - Duration: Use global ignicao timing from main.cpp -- for now, use 0 as placeholder for duration (will be properly wired in plan 02-04). OR better: access IgnicaoService stats. Read i_ignicao.h -- `getStats()` returns `IgnicaoStats` with timing. Use `ignicao_get_status()` C API for status.
    - Pack into IgnitionData struct, return 8 bytes

    `journey_state_access()` (research Pattern 3):
    - `BLE_GATT_ACCESS_OP_READ_CHR`: Pack journey data into buffer, `os_mbuf_append(ctxt->om, data, len)`. Return 0 or BLE_ATT_ERR_INSUFFICIENT_RES.
    - Other ops: return BLE_ATT_ERR_UNLIKELY

    `ignition_status_access()`:
    - Same pattern as journey: pack ignition data, append to mbuf on read.

    **gatt_diagnostics.h / gatt_diagnostics.cpp** -- System diagnostics:

    Header:
    - `struct __attribute__((packed)) DiagnosticsData` (research format): free_heap (u32), min_free_heap (u32), psram_free (u32), uptime_seconds (u32), ble_connections (u16), audio_queue_depth (u8), reserved (u8) = 16 bytes
    - `int diagnostics_access(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)`

    Implementation:
    - Include esp_timer.h, esp_heap_caps.h, simple_audio_manager.h (for queue depth if available)
    - LOG_TAG: `"GATT_DIAG"`

    `diagnostics_access()`:
    - On READ: Fill DiagnosticsData with:
      - `heap_caps_get_free_size(MALLOC_CAP_INTERNAL)` for free_heap
      - `esp_get_minimum_free_heap_size()` for min_free_heap
      - `heap_caps_get_free_size(MALLOC_CAP_SPIRAM)` for psram_free
      - `(uint32_t)(esp_timer_get_time() / 1000000)` for uptime_seconds
      - ble_connections: check if conn_handle != 0 (1 or 0)
      - audio_queue_depth: 0 for now (no public API yet, will wire later)
    - Append to mbuf, return
  </action>
  <verify>
    `pio run` compiles without errors. Check that NimBLE GATT headers resolve and all struct sizes are as expected (24, 8, 16 bytes).
  </verify>
  <done>
    GATT server module defines 3 services (DIS + Journey + Diagnostics) with 4 readable characteristics. Data packing functions produce correct binary formats. All access callbacks handle READ operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire GATT init into BLE service + build verification</name>
  <files>
    src/services/ble/ble_service.cpp
  </files>
  <action>
    1. **src/services/ble/ble_service.cpp** -- Update the init() sequence to call gatt_svr_init():
    - Add include: `#include "services/ble/gatt/gatt_server.h"`
    - In init(), AFTER `ble_svc_gap_init()` and `ble_svc_gatt_init()` calls, add: `int rc = gatt_svr_init(); if (rc != 0) { ESP_LOGE(TAG, "GATT init failed: %d", rc); return false; }`
    - REMOVE the direct `ble_svc_gap_init()` and `ble_svc_gatt_init()` calls from ble_service.cpp since gatt_svr_init() now handles them (avoid double initialization).

    2. Verify the ble_svc_dis availability:
    - If the build fails on `#include "services/dis/ble_svc_dis.h"`, remove the include and implement DIS as a custom service in the GATT table with 5 string characteristics using SIG 16-bit UUIDs (0x2A29, 0x2A24, 0x2A26, 0x2A27, 0x2A28). Each characteristic: READ only, static string buffer, simple access callback that appends the string to mbuf.
    - This is the research-recommended fallback (~30 lines of code).

    3. Run full build (`pio run`) and fix any compilation issues:
    - Common issues: NimBLE header paths may need `nimble/` prefix, packed struct alignment warnings, missing forward declarations.
    - Ensure no warnings in BLE code files.
  </action>
  <verify>
    1. `pio run` -- clean build with zero errors
    2. Flash: `pio run --target upload`
    3. Serial monitor: Verify GATT init success log, no GATT error codes
    4. nRF Connect: Connect to device, verify 3 services visible:
       - 0x180A (Device Information) with manufacturer, model, firmware, hardware, software revision readable
       - Custom Journey Service UUID with 2 characteristics (journey state + ignition), both readable
       - Custom Diagnostics Service UUID with 1 characteristic, readable
    5. Read journey state characteristic: should return 24 bytes
    6. Read ignition characteristic: should return 8 bytes
    7. Read diagnostics: should return 16 bytes with valid heap/uptime values
  </verify>
  <done>
    All 3 GATT services registered and functional. nRF Connect can discover services, read all characteristics, and see correct data formats. DIS shows correct company/model/version strings. Journey state returns packed binary data for 3 motorists. Diagnostics returns live heap and uptime values.
  </done>
</task>

</tasks>

<verification>
1. `pio run` compiles without errors
2. nRF Connect discovers Device Information Service (0x180A) with 5 characteristics
3. nRF Connect discovers Journey Service with journey state + ignition characteristics
4. nRF Connect discovers Diagnostics Service with system diagnostics characteristic
5. All characteristics are readable with correct data sizes
6. Device Info returns: "Getscale Sistemas Embarcados", "GS-Jornada", APP_VERSION_STRING, "ESP32-S3-R8", "BLE-P1.0"
</verification>

<success_criteria>
- Three GATT services registered and visible to BLE clients
- Journey state characteristic reads 24 bytes (3 motorists packed)
- Ignition characteristic reads 8 bytes (status + duration)
- Diagnostics characteristic reads 16 bytes (heap, uptime, etc.)
- Device Info Service returns correct manufacturer/model/firmware/hardware/protocol strings
- Notification val_handles captured for use in plan 02-03/02-04
- GATT-01, GATT-02, GATT-03, GATT-04, GATT-08, BLE-08 requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/02-ble-core/02-02-SUMMARY.md`
</output>
