---
phase: 02-ble-core
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - src/main.cpp
  - src/services/ble/ble_service.cpp
  - include/services/ble/gatt/gatt_journey.h
  - src/services/ble/gatt/gatt_journey.cpp
  - include/services/ble/gatt/gatt_validation.h
autonomous: true

must_haves:
  truths:
    - "BLE status icon in StatusBar updates correctly through all states when phone connects and disconnects"
    - "nRF Connect receives notification when journey state changes on the device"
    - "nRF Connect receives notification when ignition state changes on the device"
    - "Event queue consumer in main loop processes BLE events without blocking LVGL rendering"
    - "Existing UI, audio, and ignition continue working without degradation during active BLE connection"
  artifacts:
    - path: "src/main.cpp"
      provides: "BLE event queue consumer in main loop + notify trigger wiring"
      contains: "ble_process_events"
    - path: "src/services/ble/ble_service.cpp"
      provides: "ble_post_event calls in GAP event handler"
      contains: "ble_post_event"
    - path: "include/services/ble/gatt/gatt_validation.h"
      provides: "GATT write validation utility (scaffolded for Phase 3)"
      contains: "gatt_validate_write"
  key_links:
    - from: "src/main.cpp"
      to: "src/services/ble/ble_event_queue.cpp"
      via: "ble_process_events() called every 5ms in main loop"
      pattern: "ble_process_events"
    - from: "src/main.cpp"
      to: "src/ui/widgets/status_bar.cpp"
      via: "Event handler calls statusBar.setBleStatus()"
      pattern: "setBleStatus"
    - from: "src/main.cpp"
      to: "src/services/ble/gatt/gatt_journey.cpp"
      via: "notify_journey_state() called on journey state change"
      pattern: "notify_journey_state"
    - from: "src/services/ble/ble_service.cpp"
      to: "src/services/ble/ble_event_queue.cpp"
      via: "ble_post_event() called from GAP event handler on connect/disconnect/encrypt"
      pattern: "ble_post_event"
---

<objective>
Wire together all BLE components: event queue consumer in the main loop, BLE status icon updates, journey/ignition notification triggers, and scaffold the GATT write validation utility.

Purpose: This is the integration plan that connects the BLE stack (02-01), GATT services (02-02), and event queue/StatusBar (02-03) into a working end-to-end system. Without this wiring, the components exist in isolation.

Output: Fully integrated BLE system where the StatusBar reflects live BLE state, journey/ignition changes push notifications to connected clients, and the main loop processes BLE events safely on Core 0.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ble-core/02-RESEARCH.md
@.planning/phases/02-ble-core/02-01-SUMMARY.md
@.planning/phases/02-ble-core/02-02-SUMMARY.md
@.planning/phases/02-ble-core/02-03-SUMMARY.md

Key codebase files to read:
@src/main.cpp (main loop, callbacks, BLE init point)
@src/services/ble/ble_service.cpp (GAP event handler -- add ble_post_event calls)
@include/services/ble/ble_event_queue.h (event queue API)
@include/services/ble/gatt/gatt_server.h (val_handles for notification)
@include/services/ble/gatt/gatt_journey.h (pack functions)
@include/ui/widgets/status_bar.h (setBleStatus method)
@include/interfaces/i_ble.h (BleStatus enum)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire event queue into BLE service + main loop consumer + StatusBar updates</name>
  <files>
    src/services/ble/ble_service.cpp
    src/main.cpp
  </files>
  <action>
    **1. src/services/ble/ble_service.cpp** -- Add event posting to GAP handler:

    a. Add include: `#include "services/ble/ble_event_queue.h"`

    b. In `init()` method, call `ble_event_queue_init()` BEFORE starting NimBLE host task. If it fails, log error but continue (BLE still works, just no UI updates).

    c. In `gapEventHandler()`, add `ble_post_event()` calls at each state transition:
    - `BLE_GAP_EVENT_CONNECT` (success): `ble_post_event(BleStatus::CONNECTED, event->connect.conn_handle)`
    - `BLE_GAP_EVENT_CONNECT` (failure, restart adv): `ble_post_event(BleStatus::ADVERTISING)`
    - `BLE_GAP_EVENT_DISCONNECT`: `ble_post_event(BleStatus::DISCONNECTED)`
    - `BLE_GAP_EVENT_ENC_CHANGE` (success): `ble_post_event(BleStatus::SECURED, event->enc_change.conn_handle)`
    - `BLE_GAP_EVENT_MTU`: Post event with MTU value: `ble_post_event(BleStatus::CONNECTED, event->mtu.conn_handle, event->mtu.value)`
    - In `startAdvertisingInternal()`: `ble_post_event(BleStatus::ADVERTISING)`

    These calls are safe from NimBLE context because ble_post_event uses xQueueSend with 0 timeout (non-blocking).

    **2. src/main.cpp** -- Add event queue consumer and BLE event handler:

    a. Add includes:
    ```cpp
    #include "services/ble/ble_event_queue.h"
    #include "services/ble/ble_service.h"  // already added in 02-01
    ```

    b. Add a static BLE event handler function (BEFORE system_task):
    ```cpp
    static void onBleEvent(const BleEvent& evt) {
        // Atualiza icone BLE na StatusBar (LVGL-safe -- estamos no system_task Core 0)
        statusBar.setBleStatus(evt.status);

        switch (evt.status) {
            case BleStatus::DISCONNECTED:
                ESP_LOGI(TAG, "BLE: Desconectado");
                break;
            case BleStatus::ADVERTISING:
                ESP_LOGI(TAG, "BLE: Advertising...");
                break;
            case BleStatus::CONNECTED:
                ESP_LOGI(TAG, "BLE: Conectado (handle=%d)", evt.conn_handle);
                break;
            case BleStatus::SECURED:
                ESP_LOGI(TAG, "BLE: Conexao segura (handle=%d)", evt.conn_handle);
                break;
        }
    }
    ```

    c. In the main `while(1)` loop, add event queue processing. Add it BEFORE `lv_timer_handler()` so events are processed on every tick:
    ```cpp
    // Processa eventos BLE (thread-safe bridge para UI)
    ble_process_events(onBleEvent);
    ```

    This runs every 5ms (same as LVGL tick). Since ble_process_events is non-blocking and processes at most 8 events per call, it adds negligible overhead.

    d. After BLE init (the BleService::init() call), add initial status icon update:
    ```cpp
    statusBar.setBleStatus(BleStatus::ADVERTISING);
    ```
  </action>
  <verify>
    1. `pio run` -- builds without errors
    2. Flash and connect via nRF Connect:
       - At boot: BLE icon should be blue (advertising)
       - On connect: icon turns bright blue (connected)
       - After pairing/encryption: icon turns green (secured)
       - On disconnect: icon returns to blue (advertising, since device restarts adv)
    3. Serial log shows BLE state transitions
    4. LVGL rendering continues smoothly during connect/disconnect cycles
  </verify>
  <done>
    Main loop processes BLE events from queue, StatusBar BLE icon reflects live connection state (4 states), no LVGL thread safety issues, event processing adds negligible overhead to 5ms loop.
  </done>
</task>

<task type="auto">
  <name>Task 2: Journey/ignition notification triggers + GATT validation utility scaffold</name>
  <files>
    include/services/ble/gatt/gatt_journey.h
    src/services/ble/gatt/gatt_journey.cpp
    src/main.cpp
    include/services/ble/gatt/gatt_validation.h
  </files>
  <action>
    **1. Notification functions in gatt_journey.h / gatt_journey.cpp:**

    Add to header:
    - `void notify_journey_state()` -- Send notification with current journey state to subscribed client
    - `void notify_ignition_state()` -- Send notification with current ignition state to subscribed client
    - `void gatt_journey_set_conn_handle(uint16_t handle)` -- Set active connection handle for notifications
    - `void gatt_journey_set_notify_enabled(bool journey, bool ignition)` -- Track subscription state

    Add to implementation (following research Pattern 4):
    ```cpp
    static uint16_t active_conn_handle = 0;
    static bool journey_notify_enabled = false;
    static bool ignition_notify_enabled = false;

    void gatt_journey_set_conn_handle(uint16_t handle) {
        active_conn_handle = handle;
    }

    void gatt_journey_set_notify_enabled(bool journey, bool ignition) {
        journey_notify_enabled = journey;
        ignition_notify_enabled = ignition;
    }

    void notify_journey_state() {
        if (!journey_notify_enabled || active_conn_handle == 0) return;

        uint8_t data[sizeof(JourneyStateData) * MAX_MOTORISTAS];
        int len = pack_journey_states(data, sizeof(data));
        if (len <= 0) return;

        struct os_mbuf *om = ble_hs_mbuf_from_flat(data, len);
        if (om) {
            int rc = ble_gatts_notify_custom(active_conn_handle, journey_state_val_handle, om);
            if (rc != 0) {
                ESP_LOGW("GATT_JOURNEY", "Notify journey failed: %d", rc);
            }
        }
    }

    void notify_ignition_state() {
        if (!ignition_notify_enabled || active_conn_handle == 0) return;

        uint8_t data[sizeof(IgnitionData)];
        int len = pack_ignition_data(data, sizeof(data));
        if (len <= 0) return;

        struct os_mbuf *om = ble_hs_mbuf_from_flat(data, len);
        if (om) {
            int rc = ble_gatts_notify_custom(active_conn_handle, ignition_val_handle, om);
            if (rc != 0) {
                ESP_LOGW("GATT_JOURNEY", "Notify ignition failed: %d", rc);
            }
        }
    }
    ```

    **2. Wire subscription tracking in BLE service GAP handler:**

    In `ble_service.cpp`, in the `BLE_GAP_EVENT_SUBSCRIBE` case:
    ```cpp
    case BLE_GAP_EVENT_SUBSCRIBE: {
        ESP_LOGI(TAG, "Subscribe: handle=%d, attr=%d, notify=%d",
                 event->subscribe.conn_handle,
                 event->subscribe.attr_handle,
                 event->subscribe.cur_notify);

        // Track subscription per characteristic
        if (event->subscribe.attr_handle == journey_state_val_handle) {
            gatt_journey_set_notify_enabled(event->subscribe.cur_notify, /* keep ignition */);
        }
        // Similar for ignition_val_handle
        break;
    }
    ```

    Actually, for cleaner tracking, use a single function that checks which handle changed. Import gatt_server.h for val_handle externs and gatt_journey.h for set functions.

    Also in `BLE_GAP_EVENT_CONNECT` (success): `gatt_journey_set_conn_handle(event->connect.conn_handle)`
    In `BLE_GAP_EVENT_DISCONNECT`: `gatt_journey_set_conn_handle(0)`, `gatt_journey_set_notify_enabled(false, false)`

    **3. Wire notification triggers in main.cpp:**

    a. Add include: `#include "services/ble/gatt/gatt_journey.h"`

    b. In `onIgnicaoStatusChange()` callback, add at the end:
    ```cpp
    // Notifica cliente BLE sobre mudanca de ignicao
    notify_ignition_state();
    ```

    c. In `onJornadaStateChange()` callback, add:
    ```cpp
    // Notifica cliente BLE sobre mudanca de jornada
    notify_journey_state();
    ```

    d. IMPORTANT: These callbacks execute on Core 0 (from IgnicaoService monitoring task and from UI button handler respectively). NimBLE notifications via `ble_gatts_notify_custom()` are safe to call from any thread context -- they queue internally in NimBLE. However, since journey callbacks may fire from button_manager (Core 0) during LVGL processing, and notify_custom allocates mbufs, verify this does not cause issues. If needed, queue the notification via a simple flag checked in the main loop instead.

    **4. GATT write validation utility (scaffolded for Phase 3):**

    Create `include/services/ble/gatt/gatt_validation.h`:
    - Utility for GATT-09 (server-side write validation)
    - Since Phase 2 has NO writable characteristics, this is a scaffold only

    ```cpp
    #ifndef GATT_VALIDATION_H
    #define GATT_VALIDATION_H

    #include <stdint.h>
    #include <stddef.h>
    #include "host/ble_gatt.h"

    /**
     * Valida dados de escrita GATT (bounds checking, tipo, tamanho)
     * @param ctxt Contexto de acesso GATT
     * @param min_len Tamanho minimo esperado
     * @param max_len Tamanho maximo esperado
     * @return 0 se valido, BLE_ATT_ERR_* se invalido
     */
    static inline int gatt_validate_write(struct ble_gatt_access_ctxt *ctxt,
                                           size_t min_len, size_t max_len) {
        if (ctxt->op != BLE_GATT_ACCESS_OP_WRITE_CHR) {
            return BLE_ATT_ERR_REQ_NOT_SUPPORTED;
        }
        uint16_t len = OS_MBUF_PKTLEN(ctxt->om);
        if (len < min_len) {
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
        }
        if (len > max_len) {
            return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
        }
        return 0;
    }

    /**
     * Extrai dados de escrita de um mbuf para buffer
     * @param ctxt Contexto de acesso GATT
     * @param buf Buffer de destino
     * @param buf_len Tamanho do buffer
     * @return Bytes lidos, ou -1 em erro
     */
    static inline int gatt_read_write_data(struct ble_gatt_access_ctxt *ctxt,
                                            uint8_t* buf, size_t buf_len) {
        uint16_t len = OS_MBUF_PKTLEN(ctxt->om);
        if (len > buf_len) return -1;
        int rc = ble_hs_mbuf_to_flat(ctxt->om, buf, buf_len, &len);
        return (rc == 0) ? (int)len : -1;
    }

    #endif // GATT_VALIDATION_H
    ```

    This satisfies GATT-09 by providing the validation pattern. Actual usage happens in Phase 3 when writable Configuration Service characteristics are added.

    **5. Add `ble_svc_dis` include to gatt_server.cpp if available:**

    In the GATT table from plan 02-02, ensure the `BLE_GAP_EVENT_SUBSCRIBE` handler properly tracks which characteristics are subscribed. The gatt_svr_init should export val handles via extern declarations in gatt_server.h.
  </action>
  <verify>
    1. `pio run` -- builds without errors
    2. Flash and test full flow with nRF Connect:
       a. Boot: BLE icon gray -> blue (advertising starts)
       b. Connect from phone: icon turns bright blue
       c. After pairing: icon turns green (secured)
       d. In nRF Connect, enable notifications on Journey State characteristic
       e. On device, tap a journey button (e.g., change motorist 1 to JORNADA state)
       f. nRF Connect should receive notification with updated journey data
       g. Toggle ignition (if available) -- nRF Connect should receive ignition notification
       h. Disconnect from phone: icon returns to blue (advertising)
    3. Serial log shows:
       - "BLE: Conectado", "BLE: Conexao segura", "BLE: Desconectado"
       - Subscription events logged
       - Notification send success/failure logged
    4. UI remains responsive during BLE connection -- no stuttering in button presses or animations
    5. Audio playback continues without interruption during BLE activity
  </verify>
  <done>
    Full BLE integration: event queue consumer in main loop drives StatusBar icon through all 4 states. Journey and ignition state changes trigger BLE notifications to subscribed clients. GATT write validation utility scaffolded for Phase 3. All existing functionality preserved.
  </done>
</task>

</tasks>

<verification>
1. `pio run` builds cleanly
2. StatusBar BLE icon transitions: gray -> blue (boot) -> bright blue (connect) -> green (paired) -> blue (disconnect)
3. Journey notifications delivered when motorist state changes
4. Ignition notifications delivered when ignition toggles
5. Diagnostics readable with valid heap/uptime data during active connection
6. Device Info Service returns all 5 fields correctly
7. No UI stutter, audio glitch, or crash during BLE connect/disconnect/pair cycles
8. Bond survives power cycle -- device reconnects without re-pairing
</verification>

<success_criteria>
- End-to-end BLE integration working: advertise -> connect -> pair -> read -> notify -> disconnect -> re-advertise
- StatusBar reflects live BLE connection state (4 visual states)
- Notifications work for journey state and ignition changes
- GATT validation utility ready for Phase 3 writable characteristics
- All Phase 2 requirements met: INFRA-02, INFRA-03, BLE-01 through BLE-08, GATT-01 through GATT-04, GATT-08, GATT-09
- No regression in existing functionality (UI, audio, ignition, NVS persistence)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ble-core/02-04-SUMMARY.md`
</output>
