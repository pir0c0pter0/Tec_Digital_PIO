---
phase: 02-ble-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - include/services/ble/ble_event_queue.h
  - src/services/ble/ble_event_queue.cpp
  - include/ui/widgets/status_bar.h
  - src/ui/widgets/status_bar.cpp
autonomous: true

must_haves:
  truths:
    - "BLE event queue delivers events from NimBLE callbacks to system_task without LVGL thread safety violations"
    - "StatusBar displays a BLE status icon showing one of 4 states: disconnected, advertising, connected, secured"
    - "BLE icon updates in real-time when BLE state changes (connect/disconnect/pair)"
  artifacts:
    - path: "src/services/ble/ble_event_queue.cpp"
      provides: "FreeRTOS queue for BLE-to-UI events"
      contains: "xQueueSend"
    - path: "src/ui/widgets/status_bar.cpp"
      provides: "BLE status icon rendering in StatusBar"
      contains: "setBleStatus"
  key_links:
    - from: "src/services/ble/ble_event_queue.cpp"
      to: "src/services/ble/ble_service.cpp"
      via: "ble_post_event() called from GAP event handler"
      pattern: "ble_post_event"
    - from: "src/ui/widgets/status_bar.cpp"
      to: "src/services/ble/ble_event_queue.cpp"
      via: "ble_process_events() called from main loop updates StatusBar"
      pattern: "ble_process_events"
---

<objective>
Create the BLE-to-UI event queue and add a BLE status icon to the StatusBar that reflects connection state in real-time.

Purpose: NimBLE callbacks run in the NimBLE host task context and cannot call LVGL directly (thread safety). The event queue bridges BLE state changes to the UI thread. The BLE status icon gives the user immediate visual feedback about connection state.

Output: BLE event queue module (post from NimBLE, consume from system_task), StatusBar with BLE status icon showing disconnected/advertising/connected/secured states.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ble-core/02-RESEARCH.md
@.planning/phases/02-ble-core/02-01-SUMMARY.md

Key codebase files to read:
@include/ui/widgets/status_bar.h (current StatusBar API)
@src/ui/widgets/status_bar.cpp (current StatusBar layout -- BLE icon placement)
@include/interfaces/i_ble.h (BleStatus enum from plan 02-01)
@src/services/ble/ble_service.cpp (GAP event handler -- where to call ble_post_event)
</context>

<tasks>

<task type="auto">
  <name>Task 1: BLE event queue (FreeRTOS queue for BLE-to-UI bridge)</name>
  <files>
    include/services/ble/ble_event_queue.h
    src/services/ble/ble_event_queue.cpp
  </files>
  <action>
    Follow research Pattern 5 (BLE-to-UI Event Queue):

    **ble_event_queue.h:**
    - File header with section separators (Portuguese comments)
    - `#ifndef BLE_EVENT_QUEUE_H / #define BLE_EVENT_QUEUE_H`
    - Include `interfaces/i_ble.h` for BleStatus enum
    - Include `freertos/FreeRTOS.h`, `freertos/queue.h`

    Define event struct:
    ```cpp
    struct BleEvent {
        BleStatus status;          // New BLE status
        uint16_t conn_handle;      // Connection handle (0 if disconnected)
        uint16_t mtu;              // Current MTU (relevant for MTU_CHANGED)
    };
    ```

    Public functions (C++ with extern "C" wrappers not needed -- BLE is C++ only):
    - `bool ble_event_queue_init()` -- Create queue (8 items, sizeof(BleEvent)), return success
    - `void ble_post_event(BleStatus status, uint16_t conn_handle = 0, uint16_t mtu = 0)` -- Non-blocking send to queue (xQueueSend with 0 timeout). Safe to call from any core/ISR.
    - `bool ble_process_events(void (*handler)(const BleEvent& evt))` -- Receive all pending events (xQueueReceive in loop with 0 timeout), call handler for each. Returns true if any event processed. Called from system_task on Core 0 (LVGL-safe).

    **ble_event_queue.cpp:**
    - LOG_TAG: `"BLE_EVT_Q"`
    - Static `QueueHandle_t ble_event_queue = nullptr`
    - `ble_event_queue_init()`: Create queue with `xQueueCreate(8, sizeof(BleEvent))`. Log success/failure.
    - `ble_post_event()`: Build BleEvent struct, `xQueueSend(ble_event_queue, &evt, 0)`. If queue full, log warning (non-blocking, never blocks NimBLE callback).
    - `ble_process_events()`: Loop `while (xQueueReceive(..., 0) == pdTRUE)` calling handler for each event. Return true if at least one event was processed.
  </action>
  <verify>
    `pio run` compiles without errors. Queue module is standalone with no LVGL dependencies.
  </verify>
  <done>
    BLE event queue module provides thread-safe post (any context) and consume (system_task only) functions. Queue holds up to 8 events. Non-blocking on both sides.
  </done>
</task>

<task type="auto">
  <name>Task 2: BLE status icon in StatusBar</name>
  <files>
    include/ui/widgets/status_bar.h
    src/ui/widgets/status_bar.cpp
  </files>
  <action>
    Add BLE status indicator to the StatusBar. This is a small icon/label between the ignition indicator and the center area.

    **status_bar.h** -- Add:
    1. Forward include or include `interfaces/i_ble.h` for BleStatus enum
    2. New public method: `void setBleStatus(BleStatus status)` -- Update BLE icon visual
    3. New private member: `lv_obj_t* bleIcon_` (initialized to nullptr in constructor)
    4. New private member: `BleStatus bleStatus_` (initialized to BleStatus::DISCONNECTED)

    **status_bar.cpp** -- Modifications:

    1. In constructor initializer list: Add `bleIcon_(nullptr)`, `bleStatus_(BleStatus::DISCONNECTED)`

    2. In `create()` method, add BLE icon AFTER the ignition time label and BEFORE the jornada time label. Position it at approximately x=130 from left (between ignicao timer and center area):

    ```cpp
    // ---- Icone BLE (entre ignicao e centro) ----
    bleIcon_ = lv_label_create(container_);
    lv_label_set_text(bleIcon_, LV_SYMBOL_BLUETOOTH);  // LVGL built-in BT symbol
    lv_obj_align(bleIcon_, LV_ALIGN_LEFT_MID, 130, 0);
    lv_obj_set_style_text_font(bleIcon_, &lv_font_montserrat_14, LV_PART_MAIN);
    lv_obj_set_style_text_color(bleIcon_, lv_color_hex(0x666666), LV_PART_MAIN);  // Gray = disconnected
    ```

    IMPORTANT: Check if LV_SYMBOL_BLUETOOTH is available in LVGL 8.4.0 (it is defined in lv_symbol_def.h as "\xEF\x8A\x93"). If not available, use the text "BT" as fallback.

    3. Implement `setBleStatus(BleStatus status)`:
    ```cpp
    void StatusBar::setBleStatus(BleStatus status) {
        if (!bleIcon_) return;
        if (!bsp_display_lock(DISPLAY_LOCK_TIMEOUT)) return;

        bleStatus_ = status;

        switch (status) {
            case BleStatus::DISCONNECTED:
                lv_obj_set_style_text_color(bleIcon_, lv_color_hex(0x666666), LV_PART_MAIN);  // Gray
                lv_label_set_text(bleIcon_, LV_SYMBOL_BLUETOOTH);
                break;
            case BleStatus::ADVERTISING:
                lv_obj_set_style_text_color(bleIcon_, lv_color_hex(0x0088FF), LV_PART_MAIN);  // Blue (pulsing in future)
                lv_label_set_text(bleIcon_, LV_SYMBOL_BLUETOOTH);
                break;
            case BleStatus::CONNECTED:
                lv_obj_set_style_text_color(bleIcon_, lv_color_hex(0x00AAFF), LV_PART_MAIN);  // Bright blue
                lv_label_set_text(bleIcon_, LV_SYMBOL_BLUETOOTH);
                break;
            case BleStatus::SECURED:
                lv_obj_set_style_text_color(bleIcon_, lv_color_hex(0x00FF00), LV_PART_MAIN);  // Green = secured
                lv_label_set_text(bleIcon_, LV_SYMBOL_BLUETOOTH);
                break;
        }

        bsp_display_unlock();
    }
    ```

    4. In `destroy()`: Add `bleIcon_ = nullptr` after container deletion (child auto-deleted by LVGL).

    5. Adjust layout if needed: The existing tempoJornadaLabel_ is centered. The BLE icon is small (14px font) and should fit between the ignition time and center. If it overlaps, shift tempoIgnicaoLabel_ slightly left or reduce its width.

    NOTE: The `setBleStatus()` method is LVGL-safe because it acquires the display lock. It must ONLY be called from Core 0 (system_task). The event queue consumer in plan 02-04 will call this from the main loop.
  </action>
  <verify>
    1. `pio run` compiles without errors
    2. Flash and check: StatusBar shows a gray BT icon (disconnected state at boot)
    3. Visually confirm icon does not overlap with other StatusBar elements
    4. If LV_SYMBOL_BLUETOOTH is not available, fallback "BT" text renders correctly
  </verify>
  <done>
    StatusBar has a BLE status icon that renders in 4 color states (gray=disconnected, blue=advertising, bright blue=connected, green=secured). Icon positioned cleanly between ignition timer and center area. setBleStatus() method available for external callers.
  </done>
</task>

</tasks>

<verification>
1. `pio run` compiles without errors
2. BLE event queue creates successfully at init (serial log)
3. StatusBar shows BLE icon in gray (disconnected) at boot
4. StatusBar layout is clean -- no overlapping elements
5. setBleStatus() changes icon color correctly (can verify via test call in system_task)
</verification>

<success_criteria>
- BLE event queue module provides thread-safe BLE-to-UI bridge
- StatusBar displays BLE icon with 4 visual states matching BleStatus enum
- No LVGL thread safety violations -- all icon updates go through display lock
- BLE-06 (StatusBar BLE icon) and BLE-07 (event queue) requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/02-ble-core/02-03-SUMMARY.md`
</output>
