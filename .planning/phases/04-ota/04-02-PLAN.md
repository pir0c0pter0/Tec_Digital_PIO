---
phase: 04-ota
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - include/services/ota/ota_service.h
  - src/services/ota/ota_service.cpp
  - src/services/ota/ota_wifi.cpp
  - src/services/ota/ota_http_server.cpp
  - include/ui/screens/ota_screen.h
  - src/ui/screens/ota_screen.cpp
autonomous: true

must_haves:
  truths:
    - "ESP32 connects to Wi-Fi as STA using credentials received via BLE provisioning"
    - "HTTP server starts on port 8080 and accepts firmware binary via POST /update"
    - "Firmware is written to the inactive OTA partition in 4KB chunks without buffering the entire image"
    - "SHA-256 of received firmware is computed during transfer and verified against app-provided hash"
    - "OtaScreen shows progress bar with percentage, bytes received/total, and current OTA state"
    - "OTA state machine drives the flow: PROVISIONING -> CONNECTING_WIFI -> WIFI_CONNECTED -> DISABLING_BLE -> STARTING_HTTP -> WAITING_FIRMWARE -> RECEIVING -> VERIFYING -> REBOOTING"
  artifacts:
    - path: "include/services/ota/ota_service.h"
      provides: "OtaService class declaration with state machine"
      contains: "class OtaService"
    - path: "src/services/ota/ota_service.cpp"
      provides: "OTA state machine process() implementation"
      contains: "OtaService::process"
    - path: "src/services/ota/ota_wifi.cpp"
      provides: "Wi-Fi STA init, connect, shutdown functions"
      contains: "ota_wifi_connect"
    - path: "src/services/ota/ota_http_server.cpp"
      provides: "HTTP server with /update POST handler and SHA-256 verification"
      contains: "ota_upload_handler"
    - path: "include/ui/screens/ota_screen.h"
      provides: "OtaScreen IScreen implementation"
      contains: "class OtaScreen"
    - path: "src/ui/screens/ota_screen.cpp"
      provides: "Progress bar UI with state text and percentage"
      contains: "OtaScreen::updateProgress"
  key_links:
    - from: "src/services/ota/ota_http_server.cpp"
      to: "include/services/ota/ota_types.h"
      via: "OtaProgressEvent posted to queue during firmware receive"
      pattern: "ota_progress_post"
    - from: "src/services/ota/ota_service.cpp"
      to: "src/services/ota/ota_wifi.cpp"
      via: "State machine calls ota_wifi_connect in CONNECTING_WIFI state"
      pattern: "ota_wifi_connect"
    - from: "src/services/ota/ota_service.cpp"
      to: "src/services/ble/ble_service.cpp"
      via: "State machine calls BleService::shutdown() in DISABLING_BLE state"
      pattern: "shutdown"
    - from: "src/services/ota/ota_service.cpp"
      to: "src/services/ota/ota_http_server.cpp"
      via: "State machine calls ota_http_server_start in STARTING_HTTP state"
      pattern: "ota_http_server_start"
---

<objective>
Implement the OTA service core: Wi-Fi STA connection, HTTP firmware upload server with SHA-256 verification, OTA state machine orchestrator, and OtaScreen with progress bar UI.

Purpose: This is the heart of the OTA system. After Plan 01 established the BLE provisioning pathway, this plan implements the actual firmware transfer mechanism. The state machine orchestrates the full flow: Wi-Fi connection -> BLE shutdown -> HTTP server -> firmware receive + flash write -> SHA-256 verify -> reboot.

Output: Working OTA service that can receive firmware via HTTP POST, write it to the inactive OTA partition in streaming fashion (4KB chunks, never buffering 3MB in RAM), verify integrity via SHA-256, and show real-time progress on the OtaScreen.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ota/04-RESEARCH.md
@.planning/phases/04-ota/04-01-SUMMARY.md

Key source files:
@include/services/ota/ota_types.h
@include/interfaces/i_ota.h
@include/config/app_config.h
@include/services/ble/ble_service.h
@include/services/ble/gatt/gatt_ota_prov.h
@include/ui/screens/settings_screen.h
@src/ui/screens/settings_screen.cpp
@src/services/ble/ble_event_queue.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wi-Fi STA module + HTTP OTA server with SHA-256 + OTA progress queue</name>
  <files>
    src/services/ota/ota_wifi.cpp
    src/services/ota/ota_http_server.cpp
  </files>
  <action>
**1. Create `src/services/ota/ota_wifi.cpp`** (NEW file):

Wi-Fi STA management module. All functions are C-linkage (`extern "C"`) for cross-module compatibility.

- Include: esp_wifi.h, esp_event.h, esp_netif.h, esp_log.h, freertos/event_groups.h, app_config.h, string.h
- Static variables: `s_wifi_event_group` (EventGroupHandle_t), `s_retry_num` (int), `s_sta_netif` (esp_netif_t*), `s_instance_any_id` and `s_instance_got_ip` (esp_event_handler_instance_t)
- Define: `WIFI_CONNECTED_BIT (BIT0)`, `WIFI_FAIL_BIT (BIT1)`
- `static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)`:
  - WIFI_EVENT_STA_START -> esp_wifi_connect()
  - WIFI_EVENT_STA_DISCONNECTED -> retry if s_retry_num < OTA_WIFI_MAX_RETRY, else set WIFI_FAIL_BIT
  - IP_EVENT_STA_GOT_IP -> log IP, reset retry count, set WIFI_CONNECTED_BIT
- `bool ota_wifi_connect(const char* ssid, const char* password, uint32_t* out_ip_addr)`:
  - Create event group, init esp_netif, create default event loop, create default Wi-Fi STA
  - Init Wi-Fi with WIFI_INIT_CONFIG_DEFAULT()
  - Register event handlers (WIFI_EVENT + IP_EVENT)
  - Configure wifi_config_t with ssid/password via strncpy
  - Set mode STA, set config, start Wi-Fi
  - **NON-BLOCKING wait pattern for LVGL compatibility:** Do NOT use xEventGroupWaitBits with long timeout from system_task (it would block LVGL). Instead, return immediately and let the caller poll via `ota_wifi_check_status()`.
  - Actually -- since ota_service.cpp process() is called from system_task and must not block, use a different approach: Start Wi-Fi, set a flag, and let the event handler post status back via the event group. The state machine polls the event group with 0 timeout.
  - So `ota_wifi_connect()` starts Wi-Fi but returns true immediately (non-blocking). The state machine calls `ota_wifi_check_connected()` to poll.
- `bool ota_wifi_check_connected(uint32_t* out_ip_addr)`:
  - Check WIFI_CONNECTED_BIT with 0 timeout. If set, get IP from esp_netif_get_ip_info(), write to out_ip_addr, return true.
- `bool ota_wifi_check_failed()`:
  - Check WIFI_FAIL_BIT with 0 timeout. Return true if set.
- `void ota_wifi_shutdown()`:
  - Unregister event handlers, esp_wifi_stop(), esp_wifi_deinit(), esp_netif_destroy_default_wifi(s_sta_netif), esp_event_loop_delete_default()
  - Delete event group. Log completion.
- Forward-declare all public functions in a matching header (or use the ota_service.h header). Simplest: add declarations directly to `include/services/ota/ota_service.h` in an `extern "C"` block, or create a small `include/services/ota/ota_wifi.h` header.

**Create `include/services/ota/ota_wifi.h`** (NEW file):
- `bool ota_wifi_connect(const char* ssid, const char* password)` -- starts Wi-Fi (non-blocking)
- `bool ota_wifi_check_connected(uint32_t* out_ip_addr)` -- poll for connection success
- `bool ota_wifi_check_failed()` -- poll for connection failure
- `void ota_wifi_shutdown()` -- clean stop and deinit

**2. Create `src/services/ota/ota_http_server.cpp`** (NEW file):

HTTP server for OTA firmware upload. All functions C-linkage.

- Include: esp_http_server.h, esp_ota_ops.h, esp_log.h, mbedtls/sha256.h, freertos/FreeRTOS.h, freertos/queue.h, app_config.h, ota_types.h, string.h
- Static variables: `s_server` (httpd_handle_t), `s_ota_progress_queue` (QueueHandle_t), `s_expected_sha256` (uint8_t[32]), `s_sha256_provided` (bool)
- OTA progress queue (for HTTP task -> system_task UI updates):
  - `bool ota_progress_queue_init()` -- creates queue size OTA_PROGRESS_QUEUE_SIZE (1) using xQueueCreate
  - `void ota_progress_post(uint8_t percent, uint32_t received, uint32_t total, OtaState state)` -- xQueueOverwrite (size-1 queue, always latest)
  - `bool ota_progress_process(void (*handler)(const OtaProgressEvent& evt))` -- xQueueReceive with 0 timeout
- `static esp_err_t ota_upload_handler(httpd_req_t *req)`:
  - Validate content_len > 0 and content_len <= OTA_MAX_IMAGE_SIZE
  - Parse X-SHA256 header (optional): if present, decode 64-char hex string to 32 bytes in s_expected_sha256, set s_sha256_provided=true
  - Get next update partition via esp_ota_get_next_update_partition(NULL)
  - esp_ota_begin(update_partition, OTA_SIZE_UNKNOWN, &ota_handle)
  - Init mbedtls_sha256_context (sha256_init, sha256_starts with 0 for SHA-256)
  - Allocate 4KB buffer on HEAP (not stack -- avoid stack overflow per pitfall 3): `char* buf = (char*)malloc(OTA_RECEIVE_BUFFER_SIZE)`
  - Receive loop: while remaining > 0:
    - recv_len = httpd_req_recv(req, buf, MIN(remaining, OTA_RECEIVE_BUFFER_SIZE))
    - Handle HTTPD_SOCK_ERR_TIMEOUT (continue), <= 0 (abort, free buf, send error)
    - esp_ota_write(ota_handle, buf, recv_len) -- abort on error
    - mbedtls_sha256_update(&sha_ctx, buf, recv_len)
    - remaining -= recv_len
    - Compute percent, call ota_progress_post(percent, total-remaining, total, OtaState::RECEIVING)
  - After loop: free(buf)
  - mbedtls_sha256_finish -> computed_sha[32], mbedtls_sha256_free
  - If s_sha256_provided: compare computed vs expected with memcmp. On mismatch: esp_ota_abort, send 400 error "SHA-256 mismatch", post FAILED state, return ESP_FAIL
  - esp_ota_end(ota_handle) -- validates image structure
  - esp_ota_set_boot_partition(update_partition)
  - Post VERIFYING then REBOOTING state to progress queue
  - httpd_resp_sendstr(req, "{\"status\":\"ok\",\"message\":\"Rebooting...\"}")
  - ota_progress_post(100, total, total, OtaState::REBOOTING)
  - vTaskDelay(pdMS_TO_TICKS(OTA_REBOOT_DELAY_MS))
  - esp_restart() -- does not return
- `static esp_err_t ota_status_handler(httpd_req_t *req)`:
  - Returns JSON: `{"status":"ready","partition":"ota_X","max_size":3145728}`
  - Get partition info from esp_ota_get_next_update_partition
- `bool ota_http_server_start()`:
  - httpd_config_t config = HTTPD_DEFAULT_CONFIG()
  - config.stack_size = OTA_HTTP_STACK_SIZE (8192)
  - config.server_port = OTA_HTTP_SERVER_PORT (8080)
  - config.max_open_sockets = 1
  - config.recv_wait_timeout = OTA_HTTP_RECV_TIMEOUT_S (30)
  - config.send_wait_timeout = 10
  - config.core_id = 0
  - Register /update (POST) and /status (GET) URI handlers
  - Return true on success
- `void ota_http_server_stop()`:
  - httpd_stop(s_server), set s_server=NULL

**Create `include/services/ota/ota_http_server.h`** (NEW file):
- `bool ota_http_server_start()`
- `void ota_http_server_stop()`
- `bool ota_progress_queue_init()`
- `void ota_progress_post(uint8_t percent, uint32_t received, uint32_t total, OtaState state)`
- `bool ota_progress_process(void (*handler)(const OtaProgressEvent& evt))`
  </action>
  <verify>
Run `pio run` -- compiles without errors. Verify files exist: `ls src/services/ota/ota_wifi.cpp src/services/ota/ota_http_server.cpp include/services/ota/ota_wifi.h include/services/ota/ota_http_server.h`. Grep for `ota_upload_handler` in ota_http_server.cpp. Grep for `ota_wifi_connect` in ota_wifi.cpp.
  </verify>
  <done>
Wi-Fi STA module connects to AP non-blockingly and reports connection status via polling functions. HTTP server listens on port 8080 with /update POST endpoint that receives firmware in 4KB heap-allocated chunks, writes to OTA partition via esp_ota_write, computes SHA-256 during transfer, and verifies against X-SHA256 header if provided. OTA progress queue bridges HTTP task to system_task for UI updates. /status GET endpoint reports device readiness.
  </done>
</task>

<task type="auto">
  <name>Task 2: OtaService state machine + OtaScreen UI with progress bar</name>
  <files>
    include/services/ota/ota_service.h
    src/services/ota/ota_service.cpp
    include/ui/screens/ota_screen.h
    src/ui/screens/ota_screen.cpp
  </files>
  <action>
**1. Create `include/services/ota/ota_service.h`** (NEW file):
- Include ota_types.h, i_ota.h
- Class OtaService implementing IOtaService:
  - Public:
    - `static OtaService* getInstance()` -- singleton pattern per project convention
    - `bool startProvisioning(const OtaWifiCredentials& creds) override`
    - `void abort() override`
    - `OtaState getState() const override`
    - `void process() override` -- call from system_task main loop
  - Private:
    - `OtaState state_`
    - `OtaWifiCredentials wifiCreds_`
    - `uint32_t stateEnteredAt_` -- for timeout detection
    - `uint32_t ipAddr_` -- acquired IP
    - Static: `instance_`
    - `void transitionTo(OtaState newState)` -- logs transition, updates stateEnteredAt_, notifies GATT status
    - `void processIdle()`, `processConnectingWifi()`, `processWifiConnected()`, `processDisablingBle()`, `processStartingHttp()`, `processWaitingFirmware()`, `processReceiving()`, `processVerifying()`, `processAborting()` -- per-state handlers

**2. Create `src/services/ota/ota_service.cpp`** (NEW file):
- Implement singleton pattern
- `startProvisioning(creds)`: Only valid in IDLE state. Copy creds, transition to CONNECTING_WIFI. Call ota_wifi_connect(creds.ssid, creds.password). Return true.
- `abort()`: If state != IDLE && state != FAILED: transition to ABORTING.
- `process()`: Switch on state_, call the per-state handler. This is called every 5ms from system_task.
  - **IDLE:** Nothing to do.
  - **CONNECTING_WIFI:** Poll ota_wifi_check_connected(&ipAddr_). If connected: store IP, transition to WIFI_CONNECTED. If ota_wifi_check_failed(): transition to FAILED. Add timeout check (OTA_WIFI_CONNECT_TIMEOUT_MS from stateEnteredAt_) -> FAILED.
  - **WIFI_CONNECTED:** Notify GATT IP address characteristic (ota_prov_set_ip_addr), then immediately transition to DISABLING_BLE. The app already has the IP before BLE goes down.
  - **DISABLING_BLE:** Call BleService::getInstance()->shutdown(). Transition to STARTING_HTTP.
  - **STARTING_HTTP:** Call ota_progress_queue_init(), ota_http_server_start(). If success: transition to WAITING_FIRMWARE. Else: FAILED.
  - **WAITING_FIRMWARE:** Nothing -- HTTP handler will post progress when firmware starts arriving. The state machine polls ota_progress_process. If an event arrives with state RECEIVING: transition to RECEIVING.
  - **RECEIVING:** Poll ota_progress_process. Forward events to OtaScreen UI update callback (set via setter). State remains RECEIVING until progress event has state VERIFYING or REBOOTING.
  - **VERIFYING:** Short state -- progress event with REBOOTING means verification passed. Transition to REBOOTING. The reboot happens from the HTTP handler (esp_restart).
  - **ABORTING:** Stop HTTP server (ota_http_server_stop), shutdown Wi-Fi (ota_wifi_shutdown). Transition to FAILED.
  - **FAILED:** Terminal state. User must reboot.
  - **REBOOTING:** Nothing -- device is about to reboot from HTTP handler.

- Add a progress callback: `void setProgressCallback(void (*cb)(const OtaProgressEvent&))` -- stored internally, called when progress events arrive.

**3. Create `include/ui/screens/ota_screen.h`** (NEW file):
- Follow SettingsScreen pattern exactly (direct LVGL widgets, no ButtonManager).
- Class OtaScreen : public IScreen:
  - Public IScreen interface: getType() returns ScreenType::OTA, create/destroy/isCreated/update/onEnter/onExit/getLvScreen/invalidate
  - Public: `void updateProgress(uint8_t percent, uint32_t received, uint32_t total)` -- updates progress bar and labels
  - Public: `void updateState(OtaState state)` -- updates state text label
  - Public: `void showError(const char* message)` -- shows error message
  - Private: screen_, created_, progressBar_ (lv_bar), percentLabel_, bytesLabel_, stateLabel_, errorLabel_

**4. Create `src/ui/screens/ota_screen.cpp`** (NEW file):
- Layout (480x320, 40px status bar at top = 280px usable area):
  - Title label: "Atualizacao de Firmware" centered at y=50 (from screen top, which is y=50 in the 320px screen)
  - State label: shows current OTA state text in Portuguese, centered at y=90. Examples: "Conectando ao Wi-Fi...", "Desligando Bluetooth...", "Iniciando servidor...", "Aguardando firmware...", "Recebendo firmware...", "Verificando integridade...", "Reiniciando..."
  - Progress bar (lv_bar): full width (440px) centered, at y=130. Range 0-100. Blue indicator.
  - Percent label: "0%" centered above bar, updated to "XX%"
  - Bytes label: "0 / 0 KB" centered below bar, updated to "XXX / YYY KB"
  - Error label: hidden by default, shown in red when showError() called
  - Background: dark (THEME_BG_PRIMARY)
  - No back button (UI locked during OTA per OTA-08)
  - No interactive elements except display

- `create()`: Allocate lv_obj_create(NULL) for screen_. Set background color. Create all labels and progress bar. Mark created_=true.
- `updateProgress(percent, received, total)`: Set lv_bar_set_value(progressBar_, percent, LV_ANIM_ON). Update percentLabel_ text ("XX%"). Update bytesLabel_ text ("XXX / YYY KB" using received/1024 and total/1024).
- `updateState(state)`: Map OtaState enum to Portuguese string. Set stateLabel_ text.
- `showError(msg)`: Set errorLabel_ text, make visible, set red color.
- `update()`: No-op (progress updated via explicit method calls).
- `getType()`: return ScreenType::OTA
- `destroy()`: Delete screen_ LVGL object, clear all widget pointers, set created_=false.
  </action>
  <verify>
Run `pio run` -- compiles without errors. Verify files exist: `ls include/services/ota/ota_service.h src/services/ota/ota_service.cpp include/ui/screens/ota_screen.h src/ui/screens/ota_screen.cpp`. Grep for `OtaService::process` in ota_service.cpp. Grep for `OtaScreen::updateProgress` in ota_screen.cpp.
  </verify>
  <done>
OtaService state machine drives the full OTA flow from CONNECTING_WIFI through REBOOTING with proper error handling and abort capability. Wi-Fi connection is non-blocking (polling from process()). BLE shutdown is called from system_task context (safe). OtaScreen displays real-time progress with percentage, bytes transferred, state text in Portuguese, and error messages. All state transitions are logged and notified to the GATT OTA status characteristic.
  </done>
</task>

</tasks>

<verification>
1. `pio run` compiles cleanly
2. OtaService state machine has transitions for all 12 OtaState values
3. Wi-Fi connection is non-blocking (polling pattern, not blocking xEventGroupWaitBits)
4. HTTP handler uses heap-allocated 4KB buffer (not stack) to avoid stack overflow
5. SHA-256 is computed incrementally during transfer (mbedtls_sha256_update per chunk)
6. OtaScreen has progress bar, percentage label, bytes label, and state text
7. No interactive elements on OtaScreen (UI locked per OTA-08)
</verification>

<success_criteria>
- Wi-Fi STA module connects non-blockingly and reports IP address
- HTTP server on port 8080 receives firmware via POST /update in 4KB chunks
- Firmware is written to inactive OTA partition via esp_ota_write without full-image RAM buffering
- SHA-256 verified against X-SHA256 header when provided
- OtaService state machine orchestrates the full flow with proper transitions and timeouts
- OtaScreen shows real-time progress bar with percentage and bytes
- Full project builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-ota/04-02-SUMMARY.md`
</output>
