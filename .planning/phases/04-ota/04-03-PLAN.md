---
phase: 04-ota
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/services/ota/ota_self_test.cpp
  - include/services/ota/ota_self_test.h
  - src/main.cpp
  - include/ui/screen_manager.h
  - src/ui/screen_manager.cpp
  - src/ui/widgets/status_bar.cpp
autonomous: false

must_haves:
  truths:
    - "After OTA reboot, the device runs a self-test (BLE, LVGL, touch, NVS, audio) and only marks firmware valid if all pass"
    - "If self-test fails or does not complete within 60 seconds, the device automatically rolls back to previous firmware"
    - "Mobile app can trigger OTA by writing Wi-Fi credentials to BLE, and the device progresses through the full OTA flow showing progress on OtaScreen"
    - "UI is locked during OTA -- navigation buttons are disabled, only OtaScreen is visible"
    - "After failed OTA (abort or error), device reboots back to normal operation with BLE active"
  artifacts:
    - path: "src/services/ota/ota_self_test.cpp"
      provides: "Post-OTA self-test and rollback logic"
      contains: "ota_self_test"
    - path: "include/services/ota/ota_self_test.h"
      provides: "Self-test function declaration"
      contains: "ota_self_test"
    - path: "src/main.cpp"
      provides: "Full OTA integration: self-test at boot, OtaScreen registration, OTA event processing in main loop, navigation lock"
      contains: "ota_self_test"
  key_links:
    - from: "src/main.cpp"
      to: "src/services/ota/ota_self_test.cpp"
      via: "Called early in system_task before normal operation"
      pattern: "ota_self_test"
    - from: "src/main.cpp"
      to: "src/services/ota/ota_service.cpp"
      via: "OTA state machine process() called in main loop, OTA provisioning events trigger startProvisioning()"
      pattern: "otaService.*process"
    - from: "src/ui/screen_manager.cpp"
      to: "main.cpp"
      via: "Navigation lock prevents screen changes during OTA"
      pattern: "navigationLocked"
---

<objective>
Complete the OTA system: post-reboot self-test with automatic rollback, main.cpp integration (OtaScreen, OTA state machine, provisioning event handler, navigation lock), and end-to-end OTA flow verification.

Purpose: This final plan wires everything together and adds the safety net that prevents bricked devices. The self-test runs on every boot after OTA and validates that critical subsystems (BLE, LVGL, touch, NVS, audio) work correctly before marking the firmware as valid. If anything fails, the bootloader automatically rolls back.

Output: Complete, working OTA system. A mobile app can send Wi-Fi credentials via BLE, the device connects to Wi-Fi, receives firmware via HTTP, verifies SHA-256, reboots, runs self-test, and confirms the new firmware. If anything goes wrong, automatic rollback ensures the device is never bricked.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ota/04-RESEARCH.md
@.planning/phases/04-ota/04-01-SUMMARY.md
@.planning/phases/04-ota/04-02-SUMMARY.md

Key source files:
@src/main.cpp
@include/ui/screen_manager.h
@src/ui/screen_manager.cpp
@src/ui/widgets/status_bar.cpp
@include/services/ota/ota_types.h
@include/services/ota/ota_service.h
@include/ui/screens/ota_screen.h
@include/services/ble/gatt/gatt_ota_prov.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Self-test module + navigation lock + main.cpp OTA integration</name>
  <files>
    include/services/ota/ota_self_test.h
    src/services/ota/ota_self_test.cpp
    include/ui/screen_manager.h
    src/ui/screen_manager.cpp
    src/ui/widgets/status_bar.cpp
    src/main.cpp
  </files>
  <action>
**1. Create `include/services/ota/ota_self_test.h`** (NEW file):
- C-linkage header with:
  - `void ota_self_test(void)` -- runs self-test if firmware is in PENDING_VERIFY state, marks valid or triggers rollback
  - Called early in system_task, before normal init sequence

**2. Create `src/services/ota/ota_self_test.cpp`** (NEW file):
- Include: esp_ota_ops.h, esp_log.h, lvgl.h, services/nvs/nvs_manager.h, services/ble/ble_service.h, simple_audio_manager.h
- Implementation of `ota_self_test()`:
  ```
  1. Get running partition: esp_ota_get_running_partition()
  2. Get OTA state: esp_ota_get_state_partition(running, &ota_state)
  3. If ota_state != ESP_OTA_IMG_PENDING_VERIFY: return early (normal boot)
  4. Log: "Primeiro boot apos OTA -- executando self-test..."
  5. Run diagnostic checks:
     a. LVGL display: lv_disp_get_default() != NULL
     b. NVS: NvsManager::getInstance()->init() returns true
     c. BLE: BleService::getInstance()->init() returns true
     d. Audio: initSimpleAudio() returns true (or does not crash)
     Note: Touch test is complex (I2C bus probe). For v2.0 skip touch test
     -- the fact that LVGL display initialized means the display bus is working.
     The existing init flow will validate touch during normal BSP startup.
  6. If all pass:
     - esp_ota_mark_app_valid_cancel_rollback()
     - Log: "Self-test APROVADO -- firmware confirmado"
  7. If any fail:
     - Log: "Self-test FALHOU -- revertendo para firmware anterior!"
     - esp_ota_mark_app_invalid_rollback_and_reboot()
     - Does not return (reboots into previous firmware)
  ```

  IMPORTANT: Self-test must be careful about order. The self-test runs BEFORE the normal system_task init sequence. So it needs to:
  - NVS: call init on the manager (will be called again in normal flow, that's OK -- it returns true if already init)
  - BLE: call init (same -- BleService::init() returns true if already initialized)
  - Audio: call initSimpleAudio() (idempotent -- checks if already initialized)
  - LVGL: at this point in boot, LVGL is already initialized by app_main (bsp_display_start_with_config runs before system_task starts). So lv_disp_get_default() should be non-null.

  The self-test can also use the existing bootloader rollback watchdog. If CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE=y is set (it is), and the firmware never calls esp_ota_mark_app_valid_cancel_rollback(), the bootloader will NOT automatically rollback (it just stays in PENDING_VERIFY state on every boot). For automatic rollback on timeout, use esp_task_wdt:
  - Subscribe system_task to task watchdog with OTA_SELF_TEST_TIMEOUT_S (60s) timeout
  - If self-test hangs or firmware crashes before calling mark_valid, the watchdog reboots the device
  - After rollback, the previous firmware (which is already marked VALID) boots normally

  Actually, the simpler approach per ESP-IDF docs: If the device reboots without calling mark_valid (due to crash/watchdog), the bootloader checks ota_state which is still PENDING_VERIFY and boots the OTHER partition (rollback). So we just need to ensure the device reboots on failure (which esp_ota_mark_app_invalid_rollback_and_reboot does, or a crash/watchdog does).

  For the 60-second watchdog: At the start of self-test, configure esp_task_wdt with OTA_SELF_TEST_TIMEOUT_S. After self-test passes and mark_valid is called, remove the watchdog. This protects against self-test hanging.

**3. Modify `include/ui/screen_manager.h`**:
- Add to ScreenManagerImpl public interface:
  - `void setNavigationLocked(bool locked)` -- when true, navigateTo/goBack/cycleTo all refuse to switch screens
  - `bool isNavigationLocked() const`
- Add private member: `bool navigationLocked_`
- Initialize to false in constructor

**4. Modify `src/ui/screen_manager.cpp`**:
- In constructor: initialize `navigationLocked_ = false`
- In `navigateTo()`: add at start: `if (navigationLocked_) { ESP_LOGW(TAG, "Navegacao bloqueada (OTA em progresso)"); return; }`
- In `goBack()`: same guard, return false
- In `cycleTo()`: same guard, return
- Implement `setNavigationLocked(bool locked)`: `navigationLocked_ = locked; ESP_LOGI(TAG, "Navegacao %s", locked ? "bloqueada" : "desbloqueada");`
- Implement `isNavigationLocked()`: return navigationLocked_

**5. Modify `src/ui/widgets/status_bar.cpp`**:
- In the menu button callback: add check `if (screenMgr && screenMgr->isNavigationLocked()) return;` at the top (before cycling screens). This requires the StatusBar to have access to ScreenManagerImpl or use the IScreenManager pointer it already has. Since IScreenManager doesn't have isNavigationLocked(), either:
  a. Add `virtual bool isNavigationLocked() const` to IScreenManager interface (in i_screen.h) -- cleanest
  b. Or cast to ScreenManagerImpl (dirty)
  - Choose option (a): Add `virtual bool isNavigationLocked() const = 0` to IScreenManager in i_screen.h. Implement in ScreenManagerImpl. StatusBar already has IScreenManager* pointer, so it can call isNavigationLocked().
  - Also add `virtual void setNavigationLocked(bool locked) = 0` to IScreenManager.

  NOTE: Since i_screen.h is an interface, adding a pure virtual method means all implementers must provide it. There is only ScreenManagerImpl, so this is safe.

  Update `include/interfaces/i_screen.h`: Add to IScreenManager:
  ```cpp
  virtual bool isNavigationLocked() const = 0;
  virtual void setNavigationLocked(bool locked) = 0;
  ```

**6. Modify `src/main.cpp`** -- the big integration:

Add includes:
- `#include "services/ota/ota_self_test.h"`
- `#include "services/ota/ota_service.h"`
- `#include "services/ota/ota_types.h"`
- `#include "services/ble/gatt/gatt_ota_prov.h"`
- `#include "ui/screens/ota_screen.h"`

Add static variables:
- `static OtaScreen otaScreen;`
- `static OtaService* otaService = nullptr;`

In `system_task`, EARLY (after splash done, before NVS init):
- Call `ota_self_test();` -- checks if we're on first boot after OTA, runs diagnostics, marks valid or rolls back

After BLE init success block, add:
- `ota_prov_event_queue_init();` -- initialize OTA provisioning event queue

After screen registrations (where jornadaScreen, numpadScreen, settingsScreen are registered):
- `screenMgr->registerScreen(&otaScreen);`
- `otaScreen.create();` -- pre-create like other screens

Initialize OTA service:
- `otaService = OtaService::getInstance();`

Add OTA provisioning event handler:
```cpp
static void onOtaProvEvent(const OtaProvEvent& evt) {
    if (evt.type == OTA_PROV_EVT_WIFI_CREDS && otaService) {
        ESP_LOGI(TAG, "OTA: credenciais Wi-Fi recebidas, iniciando OTA...");

        // 1. Bloqueia navegacao
        if (screenMgr) {
            screenMgr->setNavigationLocked(true);
        }

        // 2. Navega para OtaScreen (force -- bypass lock temporarily)
        // Need to unlock briefly to navigate, then re-lock
        // OR: navigate before locking. Better approach:
        if (screenMgr) {
            screenMgr->cycleTo(ScreenType::OTA);
            screenMgr->setNavigationLocked(true);
        }

        // 3. Inicia OTA
        otaService->startProvisioning(evt.creds);
    }
}
```

In main loop, add after config_process_events:
```cpp
// Processa eventos de provisionamento OTA
ota_prov_process_events(onOtaProvEvent);

// Processa state machine OTA
if (otaService && otaService->getState() != OtaState::IDLE) {
    otaService->process();

    // Processa eventos de progresso OTA para atualizar UI
    ota_progress_process([](const OtaProgressEvent& evt) {
        if (screenMgr && screenMgr->getCurrentScreen() == ScreenType::OTA) {
            otaScreen.updateProgress(evt.percent, evt.bytes_received, evt.bytes_total);
            otaScreen.updateState(evt.state);
        }
    });
}
```

NOTE about lambda: ota_progress_process takes a C function pointer `void (*handler)(const OtaProgressEvent&)`. A lambda without captures can decay to a function pointer. But accessing `screenMgr` and `otaScreen` (which are file-scope statics in main.cpp) from inside the lambda is a capture. This won't work with a C function pointer.

Solution: Create a static function instead:
```cpp
static void onOtaProgress(const OtaProgressEvent& evt) {
    if (screenMgr && screenMgr->getCurrentScreen() == ScreenType::OTA) {
        otaScreen.updateProgress(evt.percent, evt.bytes_received, evt.bytes_total);
        otaScreen.updateState(evt.state);
    }
}
```
Then in loop: `ota_progress_process(onOtaProgress);`

ALSO: Handle OTA completion/failure in the loop:
```cpp
if (otaService) {
    OtaState otaState = otaService->getState();
    if (otaState == OtaState::FAILED) {
        ESP_LOGE(TAG, "OTA falhou! Reiniciando...");
        otaScreen.showError("Falha na atualizacao. Reiniciando...");
        vTaskDelay(pdMS_TO_TICKS(3000)); // Show error for 3 seconds
        esp_restart(); // Reboot to normal operation (BLE reinitializes)
    }
}
```

4-way StatusBar menu cycle update (from 3-way to 4-way is NOT needed -- OtaScreen is not in the normal cycle, it's only accessed via BLE provisioning trigger. The menu cycle stays: NUMPAD -> JORNADA -> SETTINGS -> NUMPAD).
  </action>
  <verify>
Run `pio run` -- full project compiles with zero errors. Grep for `ota_self_test` in main.cpp. Grep for `navigationLocked` in screen_manager.cpp. Grep for `onOtaProvEvent` in main.cpp. Grep for `ota_progress_process` in main.cpp.
  </verify>
  <done>
Self-test runs on first boot after OTA, validates BLE/LVGL/NVS/audio, marks firmware valid or triggers rollback. Navigation lock prevents accidental screen switching during OTA. OtaScreen registered and pre-created. OTA provisioning events from BLE trigger full OTA flow. Progress events update OtaScreen in real time. Failed OTA shows error then reboots back to normal. 60-second watchdog protects against hung self-test.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify OTA end-to-end on hardware</name>
  <files>src/main.cpp</files>
  <action>
Human verification checkpoint. Claude has built the complete OTA system:
- BLE provisioning of Wi-Fi credentials
- Wi-Fi STA connection, BLE shutdown
- HTTP server on port 8080, firmware upload via POST /update
- SHA-256 verification, OtaScreen with progress bar
- Self-test at boot, automatic rollback on failure
- Navigation lock during OTA

The user must verify the end-to-end flow on real hardware.
  </action>
  <verify>
1. Flash firmware via USB: `pio run --target upload`
2. Open serial monitor in a separate terminal
3. Verify device boots normally with BLE advertising
4. Connect with nRF Connect (or your BLE test app)
5. Find the OTA Provisioning Service (UUID 00000400-...)
6. Write Wi-Fi credentials to the Wi-Fi Creds characteristic:
   - Format: [1B ssid_len][ssid bytes][1B pwd_len][pwd bytes]
   - Example for SSID "test" password "12345678": 04 74 65 73 74 08 31 32 33 34 35 36 37 38
7. Observe serial log:
   - "OTA: credenciais Wi-Fi recebidas, iniciando OTA..."
   - "Conectando ao Wi-Fi..." (state transition)
   - "Got IP: X.X.X.X"
   - "Desligando BLE completamente..."
   - "BLE desligado. Heap livre interno: XXXXX bytes"
   - "HTTP server iniciado na porta 8080"
8. From a computer on the same Wi-Fi, upload a test firmware:
   - `curl -X POST --data-binary @.pio/build/esp32-s3-devkitc-1/firmware.bin http://DEVICE_IP:8080/update`
   - OR with SHA-256: first compute hash, then add header: `-H "X-SHA256: HASH"`
9. Observe OtaScreen showing progress bar filling up
10. Device reboots, runs self-test, confirms firmware
11. Device boots normally again with BLE advertising

**Rollback test (OPTIONAL but recommended):**
- Build a deliberately broken firmware (e.g., comment out BLE init in self-test), upload via OTA
- Device should reboot into old firmware after self-test fails
  </verify>
  <done>
User confirms OTA flow works end-to-end on hardware: BLE provisioning -> Wi-Fi connection -> firmware upload -> SHA-256 verification -> reboot -> self-test -> firmware confirmed. Navigation is locked during OTA. Rollback works if self-test fails.
  </done>
</task>

</tasks>

<verification>
1. `pio run` compiles cleanly with zero errors
2. Self-test runs early in boot and calls esp_ota_mark_app_valid_cancel_rollback() or esp_ota_mark_app_invalid_rollback_and_reboot()
3. Navigation lock prevents screen switching during OTA (navigateTo/goBack/cycleTo all guarded)
4. OtaScreen is registered, pre-created, and accessible via ScreenType::OTA
5. OTA provisioning events are consumed in main loop and trigger OtaService::startProvisioning()
6. Progress events update OtaScreen in real time from main loop
7. Failed OTA shows error for 3 seconds then reboots
8. End-to-end OTA flow works on hardware: BLE provisioning -> Wi-Fi -> HTTP upload -> reboot -> self-test -> confirmed
</verification>

<success_criteria>
- Self-test validates BLE, LVGL, NVS, and audio after OTA reboot
- Firmware marked valid only after all self-test checks pass
- Rollback triggers automatically if self-test fails (via esp_ota_mark_app_invalid_rollback_and_reboot)
- Navigation locked during OTA (menu/back buttons disabled)
- Full OTA flow wired in main.cpp: provisioning event -> OtaScreen -> state machine -> progress -> reboot
- End-to-end verification on hardware confirms the complete OTA cycle works
</success_criteria>

<output>
After completion, create `.planning/phases/04-ota/04-03-SUMMARY.md`
</output>
