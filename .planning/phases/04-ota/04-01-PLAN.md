---
phase: 04-ota
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/config/app_config.h
  - include/config/ble_uuids.h
  - include/services/ota/ota_types.h
  - include/interfaces/i_ota.h
  - include/services/ble/gatt/gatt_ota_prov.h
  - src/services/ble/gatt/gatt_ota_prov.cpp
  - src/services/ble/gatt/gatt_server.cpp
  - include/services/ble/ble_service.h
  - src/services/ble/ble_service.cpp
autonomous: true

must_haves:
  truths:
    - "OTA provisioning service is discoverable in GATT table with Wi-Fi credentials, status, and IP address characteristics"
    - "App can write Wi-Fi SSID+password to the provisioning characteristic and the device posts it to an event queue"
    - "BleService has a shutdown() method that cleanly stops NimBLE and frees ~50KB internal SRAM"
    - "OTA state machine enum and event types are defined and ready for use by the OTA service"
  artifacts:
    - path: "include/services/ota/ota_types.h"
      provides: "OtaState enum, OtaProgressEvent struct, OtaWifiCredentials struct"
      contains: "OtaState"
    - path: "include/interfaces/i_ota.h"
      provides: "IOtaService abstract interface"
      contains: "class IOtaService"
    - path: "include/services/ble/gatt/gatt_ota_prov.h"
      provides: "OTA provisioning GATT callbacks and event queue"
      contains: "ota_prov_wifi_creds_access"
    - path: "src/services/ble/gatt/gatt_ota_prov.cpp"
      provides: "GATT OTA provisioning characteristic handlers"
      contains: "ota_prov_wifi_creds_access"
    - path: "include/config/ble_uuids.h"
      provides: "OTA provisioning service UUID + 3 characteristic UUIDs (group 4)"
      contains: "BLE_UUID_OTA_PROV_SVC"
  key_links:
    - from: "src/services/ble/gatt/gatt_ota_prov.cpp"
      to: "include/services/ota/ota_types.h"
      via: "OtaWifiCredentials struct used in GATT write handler"
      pattern: "OtaWifiCredentials"
    - from: "src/services/ble/gatt/gatt_server.cpp"
      to: "include/services/ble/gatt/gatt_ota_prov.h"
      via: "OTA provisioning service added to GATT table"
      pattern: "BLE_UUID_OTA_PROV_SVC"
    - from: "src/services/ble/ble_service.cpp"
      to: "nimble_port_stop"
      via: "BLE shutdown sequence for OTA"
      pattern: "nimble_port_stop"
---

<objective>
Create the OTA foundation: type definitions, OTA provisioning GATT service (Wi-Fi credentials, status, IP address characteristics), BLE shutdown method, and OTA event queue for provisioning events.

Purpose: Establish the BLE-side infrastructure that allows a mobile app to send Wi-Fi credentials to the ESP32 and trigger OTA mode. The BLE shutdown method is critical because BLE must be fully stopped before Wi-Fi starts (per user decision: disable BLE during OTA to free ~50KB RAM).

Output: OTA types/enums, GATT OTA provisioning service with 3 characteristics registered in the GATT table, BLE shutdown capability, OTA provisioning event queue, and all OTA constants in app_config.h.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ota/04-RESEARCH.md

Key source files:
@include/config/app_config.h
@include/config/ble_uuids.h
@include/interfaces/i_screen.h
@include/services/ble/ble_service.h
@src/services/ble/ble_service.cpp
@src/services/ble/gatt/gatt_server.cpp
@include/services/ble/gatt/gatt_config.h
@src/services/ble/gatt/gatt_ota_prov.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: OTA types, interface, constants, UUIDs, and provisioning event queue</name>
  <files>
    include/services/ota/ota_types.h
    include/interfaces/i_ota.h
    include/config/app_config.h
    include/config/ble_uuids.h
    include/services/ble/gatt/gatt_ota_prov.h
    src/services/ble/gatt/gatt_ota_prov.cpp
  </files>
  <action>
**1. Create `include/services/ota/ota_types.h`** (NEW file):
- `OtaState` enum class (uint8_t): IDLE, PROVISIONING, CONNECTING_WIFI, WIFI_CONNECTED, DISABLING_BLE, STARTING_HTTP, WAITING_FIRMWARE, RECEIVING, VERIFYING, REBOOTING, ABORTING, FAILED
- `OtaProgressEvent` struct: `uint8_t percent` (0-100), `uint32_t bytes_received`, `uint32_t bytes_total`, `OtaState state`
- `OtaWifiCredentials` struct: `char ssid[33]`, `char password[65]`, `bool valid`
- `OtaProvEventType` enum: OTA_PROV_EVT_WIFI_CREDS
- `OtaProvEvent` struct: `OtaProvEventType type`, `OtaWifiCredentials creds`
- Include guards, stdint.h, stdbool.h. Wrap in `extern "C"` for C compatibility of the enums and structs.

**2. Create `include/interfaces/i_ota.h`** (NEW file):
- C++ abstract class `IOtaService` with pure virtual methods:
  - `bool startProvisioning(const OtaWifiCredentials& creds)` -- starts OTA flow
  - `void abort()` -- cancels OTA in progress
  - `OtaState getState() const` -- current state
  - `void process()` -- drive state machine forward (called from system_task loop)
- Include ota_types.h

**3. Modify `include/config/app_config.h`**:
- Add OTA Wi-Fi constants section after existing OTA section:
```
// ============================================================================
// CONFIGURACOES DE OTA (Wi-Fi)
// ============================================================================

#define OTA_HTTP_SERVER_PORT        8080
#define OTA_HTTP_STACK_SIZE         8192
#define OTA_HTTP_RECV_TIMEOUT_S     30
#define OTA_RECEIVE_BUFFER_SIZE     4096
#define OTA_MAX_IMAGE_SIZE          (3 * 1024 * 1024)
#define OTA_WIFI_CONNECT_TIMEOUT_MS 15000
#define OTA_WIFI_MAX_RETRY          5
#define OTA_REBOOT_DELAY_MS         500
#define OTA_BLE_DISCONNECT_DELAY_MS 200
#define OTA_PROGRESS_QUEUE_SIZE     1
#define OTA_PROV_EVENT_QUEUE_SIZE   4
```

**4. Modify `include/config/ble_uuids.h`**:
- Add OTA Provisioning Service (group 4) section after Diagnostics:
  - `BLE_UUID_OTA_PROV_SVC`: 00000400-4A47-0000-4763-7365-00000004 (little-endian bytes: 04,00,00,00,65,73,63,47,00,00,4A,47,00,04,00,00)
  - `BLE_UUID_OTA_PROV_WIFI_CREDS_CHR`: 00000401-... (04,00,00,00,...,01,04,00,00) -- Write-only
  - `BLE_UUID_OTA_PROV_STATUS_CHR`: 00000402-... (04,00,00,00,...,02,04,00,00) -- Read+Notify
  - `BLE_UUID_OTA_PROV_IP_ADDR_CHR`: 00000403-... (04,00,00,00,...,03,04,00,00) -- Read+Notify
- Follow exact same little-endian BLE_UUID128_INIT pattern as existing UUIDs.

**5. Create `include/services/ble/gatt/gatt_ota_prov.h`** (NEW file):
- Follow gatt_config.h pattern exactly: extern "C", forward declarations, C-linkage functions.
- GATT access callbacks:
  - `int ota_prov_wifi_creds_access(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt* ctxt, void* arg)` -- Write handler
  - `int ota_prov_status_access(...)` -- Read handler (returns OtaState as 2 bytes: state + error_code)
  - `int ota_prov_ip_addr_access(...)` -- Read handler (returns IP as 4 bytes or string)
- Event queue functions:
  - `bool ota_prov_event_queue_init(void)` -- create FreeRTOS queue
  - `bool ota_prov_process_events(void (*handler)(const OtaProvEvent& evt))` -- system_task consumer
- State management:
  - `void ota_prov_set_conn_handle(uint16_t handle)`
  - `void ota_prov_update_subscription(uint16_t attr_handle, bool notify)`
  - `void ota_prov_reset_subscriptions(void)`
  - `void ota_prov_set_state(uint8_t state, uint8_t error_code)` -- updates cached state, notifies
  - `void ota_prov_set_ip_addr(uint32_t ip_addr)` -- updates cached IP, notifies
- Value handle externs: `extern uint16_t gatt_ota_prov_status_val_handle`, `extern uint16_t gatt_ota_prov_ip_val_handle`

**6. Create `src/services/ble/gatt/gatt_ota_prov.cpp`** (NEW file):
- Follow gatt_config.cpp pattern: static variables, mutex-free (NimBLE single-thread callbacks).
- Static state: `s_ota_prov_conn_handle`, `s_ota_status_subscribed`, `s_ota_ip_subscribed`, `s_current_ota_state` (uint8_t), `s_current_error_code` (uint8_t), `s_current_ip_addr` (uint32_t), `s_ota_prov_event_queue` (QueueHandle_t).
- `ota_prov_wifi_creds_access` write handler:
  - Validate write operation (use gatt_validate_write from gatt_validation.h)
  - Parse format: [1B ssid_len][ssid bytes][1B pwd_len][pwd bytes]. Min 4 bytes, max 98 bytes.
  - Validate ssid_len > 0 && ssid_len <= 32, pwd_len <= 64
  - Pack into OtaWifiCredentials struct, post OtaProvEvent to queue
  - Return 0 on success, BLE_ATT_ERR_VALUE_NOT_ALLOWED on invalid data
- `ota_prov_status_access` read handler:
  - Return 2 bytes: [state, error_code] via os_mbuf_append
- `ota_prov_ip_addr_access` read handler:
  - Return 4 bytes of IP address via os_mbuf_append
- `ota_prov_set_state`: update cached state, notify if subscribed via ble_gatts_notify_custom
- `ota_prov_set_ip_addr`: update cached IP, notify if subscribed
- Event queue: ota_prov_event_queue_init creates FreeRTOS queue (OTA_PROV_EVENT_QUEUE_SIZE items), ota_prov_process_events drains with zero-timeout xQueueReceive
  </action>
  <verify>
Run `pio run` -- project compiles without errors. Verify new files exist: `ls include/services/ota/ota_types.h include/interfaces/i_ota.h include/services/ble/gatt/gatt_ota_prov.h src/services/ble/gatt/gatt_ota_prov.cpp`. Grep for `BLE_UUID_OTA_PROV_SVC` in ble_uuids.h. Grep for `OTA_HTTP_SERVER_PORT` in app_config.h.
  </verify>
  <done>
OTA types defined (OtaState 12 states, OtaProgressEvent, OtaWifiCredentials). IOtaService abstract interface created. OTA provisioning GATT service with 3 characteristics (wifi_creds write, status read+notify, ip_addr read+notify) compiles and is registered in GATT table. OTA provisioning event queue functional (init, post, process). All OTA constants in app_config.h. UUIDs for group 4 in ble_uuids.h.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register OTA GATT service in GATT table + BLE shutdown method</name>
  <files>
    src/services/ble/gatt/gatt_server.cpp
    include/services/ble/ble_service.h
    src/services/ble/ble_service.cpp
  </files>
  <action>
**1. Modify `src/services/ble/gatt/gatt_server.cpp`**:
- Add `#include "services/ble/gatt/gatt_ota_prov.h"` at top
- Add value handle declarations: `uint16_t gatt_ota_prov_status_val_handle = 0;` and `uint16_t gatt_ota_prov_ip_val_handle = 0;`
- Add OTA Provisioning Service (group 4) to `gatt_svr_svcs[]` array, BEFORE the terminator `{ 0 }`:
```cpp
// OTA Provisioning Service (custom UUID)
{
    .type = BLE_GATT_SVC_TYPE_PRIMARY,
    .uuid = &BLE_UUID_OTA_PROV_SVC.u,
    .characteristics = (struct ble_gatt_chr_def[]) {
        // Wi-Fi Credentials: escrita apenas
        {
            .uuid = &BLE_UUID_OTA_PROV_WIFI_CREDS_CHR.u,
            .access_cb = ota_prov_wifi_creds_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_WRITE,
            .min_key_size = 0,
            .val_handle = NULL,
        },
        // OTA Status: leitura + notificacao
        {
            .uuid = &BLE_UUID_OTA_PROV_STATUS_CHR.u,
            .access_cb = ota_prov_status_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_NOTIFY,
            .min_key_size = 0,
            .val_handle = &gatt_ota_prov_status_val_handle,
        },
        // IP Address: leitura + notificacao
        {
            .uuid = &BLE_UUID_OTA_PROV_IP_ADDR_CHR.u,
            .access_cb = ota_prov_ip_addr_access,
            .arg = NULL,
            .descriptors = NULL,
            .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_NOTIFY,
            .min_key_size = 0,
            .val_handle = &gatt_ota_prov_ip_val_handle,
        },
        { 0 }, // Terminador de caracteristicas
    },
},
```
- Update log message in `gatt_svr_init()`: change "DIS + Journey (2 chr) + Diagnostics (1 chr) + Config (4 chr)" to include "+ OTA Prov (3 chr)"

**2. Modify `include/services/ble/ble_service.h`**:
- Add `void shutdown()` public method declaration (after stopAdvertising)
- Add comment: "Desliga completamente o stack NimBLE, liberando ~50KB de SRAM. IRREVERSIVEL -- dispositivo reinicia apos OTA. DEVE ser chamado de system_task, NUNCA do NimBLE host task."

**3. Modify `src/services/ble/ble_service.cpp`**:
- Add `#include "services/ble/gatt/gatt_ota_prov.h"` at top
- In `gapEventHandler` CONNECT case, add: `ota_prov_set_conn_handle(event->connect.conn_handle);`
- In `gapEventHandler` DISCONNECT case, add: `ota_prov_set_conn_handle(0);` and `ota_prov_reset_subscriptions();`
- In `gapEventHandler` SUBSCRIBE case, add: `gatt_ota_prov_update_subscription(event->subscribe.attr_handle, event->subscribe.cur_notify);`
- Implement `BleService::shutdown()` method:
  ```cpp
  void BleService::shutdown() {
      if (!initialized_) {
          ESP_LOGW(TAG, "BLE nao inicializado, nada a desligar");
          return;
      }

      ESP_LOGI(TAG, "Desligando BLE completamente (liberando SRAM)...");

      // 1. Para advertising
      ble_gap_adv_stop();

      // 2. Desconecta cliente se conectado
      if (connHandle_ != 0) {
          ble_gap_terminate(connHandle_, BLE_ERR_REM_USER_CONN_TERM);
          vTaskDelay(pdMS_TO_TICKS(OTA_BLE_DISCONNECT_DELAY_MS));
      }

      // 3. Para NimBLE host (blocks until host task exits)
      // CRITICO: deve ser chamado de task diferente do NimBLE host task
      int ret = nimble_port_stop();
      if (ret == 0) {
          // 4. Deinicializa NimBLE port
          nimble_port_deinit();

          // 5. Deinicializa HCI e controller BT
          ret = esp_nimble_hci_and_controller_deinit();
          if (ret != ESP_OK) {
              ESP_LOGE(TAG, "HCI/controller deinit falhou: %s", esp_err_to_name(ret));
          }
      } else {
          ESP_LOGE(TAG, "nimble_port_stop falhou: %d", ret);
      }

      initialized_ = false;
      updateStatus(BleStatus::DISCONNECTED);

      ESP_LOGI(TAG, "BLE desligado. Heap livre interno: %lu bytes",
               (unsigned long)heap_caps_get_free_size(MALLOC_CAP_INTERNAL));
  }
  ```
- Add required includes at top: `#include "esp_heap_caps.h"` (for heap_caps_get_free_size). Also add `extern "C" { #include "esp_nimble_hci.h" }` if not already present (needed for esp_nimble_hci_and_controller_deinit).

NOTE: For `esp_nimble_hci_and_controller_deinit()` -- check if this function exists in ESP-IDF 5.3.1 NimBLE port. In ESP-IDF 5.x with NimBLE, the controller is managed internally by `nimble_port_init/deinit`. The correct deinit sequence may just be `nimble_port_stop()` + `nimble_port_deinit()` without a separate HCI call. If `esp_nimble_hci_and_controller_deinit` is not available, remove that call and just use `nimble_port_deinit()` which handles controller cleanup in ESP-IDF 5.3.1. Log heap before and after to verify RAM recovery.
  </action>
  <verify>
Run `pio run` -- full project compiles with zero errors. Grep for `ota_prov_wifi_creds_access` in gatt_server.cpp. Grep for `void shutdown()` in ble_service.h. Grep for `nimble_port_stop` in ble_service.cpp. Grep for `OTA Prov` in gatt_server.cpp log message.
  </verify>
  <done>
OTA Provisioning Service (3 characteristics) registered in GATT table alongside existing services. BleService::shutdown() method implemented with proper NimBLE teardown sequence (stop advertising, disconnect, nimble_port_stop, nimble_port_deinit). GAP event handler routes OTA provisioning connection/subscription events. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `pio run` compiles cleanly with zero errors
2. `grep -r "BLE_UUID_OTA_PROV" include/config/ble_uuids.h` shows 4 UUIDs (1 service + 3 characteristics)
3. `grep -r "OTA_HTTP_SERVER_PORT" include/config/app_config.h` shows OTA constants
4. `grep -r "OtaState" include/services/ota/ota_types.h` shows all 12 states
5. `grep -r "ota_prov_wifi_creds_access" src/services/ble/gatt/` shows implementation in gatt_ota_prov.cpp and registration in gatt_server.cpp
6. `grep -r "shutdown" include/services/ble/ble_service.h` shows new method
</verification>

<success_criteria>
- OTA provisioning GATT service with Wi-Fi credentials write characteristic compiles and is registered in the GATT table
- BleService has a shutdown() method that calls nimble_port_stop() + nimble_port_deinit()
- OTA types (OtaState enum with 12 states, OtaProgressEvent, OtaWifiCredentials) are defined
- IOtaService abstract interface is defined
- OTA provisioning event queue bridges GATT write callbacks to system_task
- All OTA constants centralized in app_config.h
- Full project builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-ota/04-01-SUMMARY.md`
</output>
