---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - include/interfaces/i_screen.h
  - include/ui/screen_manager.h
  - src/ui/screen_manager.cpp
  - include/ui/widgets/status_bar.h
  - src/ui/widgets/status_bar.cpp
autonomous: true

must_haves:
  truths:
    - "ScreenManager implements IScreenManager with push/pop navigation stack"
    - "Screen transitions are animated with lv_scr_load_anim() (slide left for push, slide right for pop, 250ms)"
    - "StatusBar lives on lv_layer_top() and remains visible across all screen transitions"
    - "StatusBar shows ignition indicator, timers, a menu button, and a back button"
    - "Back button is hidden when navigation stack is empty (home screen)"
    - "Navigation is blocked during transition animation to prevent crashes"
  artifacts:
    - path: "include/ui/screen_manager.h"
      provides: "ScreenManagerImpl class declaration"
      contains: "class ScreenManagerImpl"
    - path: "src/ui/screen_manager.cpp"
      provides: "Stack-based navigation with animated transitions"
      contains: "lv_scr_load_anim"
    - path: "include/ui/widgets/status_bar.h"
      provides: "StatusBar class with menu/back buttons"
      contains: "lv_layer_top"
    - path: "src/ui/widgets/status_bar.cpp"
      provides: "StatusBar implementation on lv_layer_top()"
      contains: "lv_layer_top"
  key_links:
    - from: "src/ui/screen_manager.cpp"
      to: "include/interfaces/i_screen.h"
      via: "Implements IScreenManager interface"
      pattern: "class ScreenManagerImpl.*IScreenManager"
    - from: "src/ui/screen_manager.cpp"
      to: "src/ui/widgets/status_bar.cpp"
      via: "ScreenManager updates StatusBar back button visibility on navigation"
      pattern: "statusBar.*setBackVisible|updateBackButton"
    - from: "src/ui/screen_manager.cpp"
      to: "include/config/app_config.h"
      via: "Uses SCREEN_TRANSITION_TIME_MS and SCREEN_NAV_STACK_MAX constants"
      pattern: "SCREEN_TRANSITION_TIME_MS"
---

<objective>
Implement the ScreenManagerImpl (stack-based navigation with animated transitions) and refactor StatusBar to live on lv_layer_top() with menu and back navigation buttons.

Purpose: This is the core navigation framework that all screens (Jornada, Numpad, Settings, OTA, RPM) will plug into. The stack pattern enables forward/back navigation. Animated transitions via lv_scr_load_anim() give the UI a polished feel. StatusBar on lv_layer_top() means it never needs to be recreated when screens change.

Output: Working ScreenManagerImpl and StatusBar that can register and navigate between IScreen implementations.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

@include/interfaces/i_screen.h
@include/config/app_config.h
@include/ui/widgets/status_bar.h
@src/ui/widgets/status_bar.cpp
@include/button_manager.h
@src/main.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ScreenManagerImpl with stack navigation and animated transitions</name>
  <files>include/interfaces/i_screen.h, include/ui/screen_manager.h, src/ui/screen_manager.cpp</files>
  <action>
  **Step 1: Extend i_screen.h** -- Add a `getLvScreen()` method to IScreen interface. This is needed so ScreenManager can pass the LVGL screen object to `lv_scr_load_anim()`. Add after the `onExit()` declaration:

  ```cpp
  /**
   * Obtem o objeto LVGL da tela
   * @return Ponteiro para o lv_obj_t da tela (ou nullptr)
   */
  virtual lv_obj_t* getLvScreen() const = 0;
  ```

  Also add `OTA` and `RPM` to the ScreenType enum (before MAX_SCREENS) for future phases. Add corresponding entries to the C-compatible enum as well.

  **Step 2: Create include/ui/screen_manager.h** with class `ScreenManagerImpl : public IScreenManager`.

  Private members:
  - `IScreen* screens_[static_cast<int>(ScreenType::MAX_SCREENS)]` -- registered screen slots (array, not map)
  - `ScreenType navStack_[SCREEN_NAV_STACK_MAX]` -- fixed-size stack array (no std::vector, we are embedded)
  - `int stackTop_` -- index of top of stack (-1 = empty)
  - `ScreenType currentScreen_` -- currently active screen type
  - `bool transitioning_` -- flag to block navigation during animation
  - `lv_timer_t* transitionTimer_` -- LVGL timer to clear transitioning_ flag after animation
  - `StatusBar* statusBar_` -- reference to the persistent status bar (forward-declared)
  - Static singleton: `static ScreenManagerImpl* instance_`
  - `static void transitionDoneCallback(lv_timer_t* timer)` -- clears transitioning_ flag

  Public methods implementing IScreenManager:
  - `void init() override` -- initializes slots to nullptr, stackTop_ = -1, transitioning_ = false
  - `void navigateTo(ScreenType type) override` -- pushes current to stack, creates new screen if needed, calls onExit/onEnter, animates with `lv_scr_load_anim(LV_SCR_LOAD_ANIM_MOVE_LEFT, SCREEN_TRANSITION_TIME_MS, 0, false)`, sets transitioning_ flag, creates one-shot timer to clear it. Updates StatusBar back button visibility.
  - `bool goBack() override` -- pops from stack, calls onExit/destroy on current, creates popped screen if needed, calls onEnter, animates with `lv_scr_load_anim(LV_SCR_LOAD_ANIM_MOVE_RIGHT, ...)`. Returns false if stack empty.
  - `void registerScreen(IScreen* screen) override` -- stores in screens_[type]
  - `ScreenType getCurrentScreen() const override`
  - `void update() override` -- calls update() on the current screen only

  Additional public methods:
  - `static ScreenManagerImpl* getInstance()`
  - `void setStatusBar(StatusBar* bar)` -- sets the status bar reference
  - `void showInitialScreen(ScreenType type)` -- loads the first screen without animation and without pushing to stack (used at boot)

  **Critical implementation details:**
  - ALL LVGL calls MUST be wrapped in `bsp_display_lock(DISPLAY_LOCK_TIMEOUT)` / `bsp_display_unlock()`. Import from `esp_bsp.h`.
  - `auto_del` parameter of `lv_scr_load_anim()` MUST be `false`. We manage screen lifecycle manually.
  - When `transitioning_` is true, `navigateTo()` and `goBack()` return immediately (log a warning, do nothing).
  - The transition timer is created with `lv_timer_create(transitionDoneCallback, SCREEN_TRANSITION_TIME_MS + 50, this)` and set to single-shot via `lv_timer_set_repeat_count(timer, 1)`. The +50ms buffer ensures LVGL animation is truly complete.
  - On `goBack()`, call `destroy()` on the screen being left (to free memory). On `navigateTo()`, do NOT destroy the previous screen (it stays alive on the stack for fast back navigation). Exception: if stack is full (SCREEN_NAV_STACK_MAX), log error and refuse.
  - The home screen (first screen shown) is NEVER destroyed (it has no stack entry below it).

  **Step 3: Create src/ui/screen_manager.cpp** implementing the above.

  Include the `extern "C"` wrapper functions declared in `i_screen.h` at the bottom:
  ```cpp
  extern "C" {
  void screen_manager_init(void) {
      ScreenManagerImpl::getInstance()->init();
  }
  void screen_navigate_to(screen_type_t type) {
      ScreenManagerImpl::getInstance()->navigateTo(static_cast<ScreenType>(type));
  }
  screen_type_t screen_get_current(void) {
      return static_cast<screen_type_t>(ScreenManagerImpl::getInstance()->getCurrentScreen());
  }
  void screen_go_back(void) {
      ScreenManagerImpl::getInstance()->goBack();
  }
  }
  ```
  </action>
  <verify>
  `pio run` compiles with no errors. Grep for `lv_scr_load_anim` in screen_manager.cpp to confirm animated transitions. Grep for `transitioning_` to confirm navigation guard exists.
  </verify>
  <done>ScreenManagerImpl exists implementing IScreenManager, with push/pop stack navigation, lv_scr_load_anim() transitions (left for push, right for pop, 250ms), transition guard flag, proper lifecycle (create on demand, destroy on pop), and display lock protection on all LVGL calls.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor StatusBar to lv_layer_top() with menu and back buttons</name>
  <files>include/ui/widgets/status_bar.h, src/ui/widgets/status_bar.cpp</files>
  <action>
  Refactor the existing StatusBar class to:

  1. **Create on lv_layer_top() instead of a parent screen.** Change `create(lv_obj_t* parent)` to `create()` (no parent parameter). Internally use `lv_layer_top()` as the parent:
  ```cpp
  container = lv_obj_create(lv_layer_top());
  ```

  2. **Position at BOTTOM of screen** (current design has status bar at bottom based on GRID_AREA_HEIGHT calculation):
  ```cpp
  lv_obj_set_size(container, DISPLAY_WIDTH, STATUS_BAR_HEIGHT);
  lv_obj_align(container, LV_ALIGN_BOTTOM_LEFT, 0, 0);
  ```

  3. **Make container non-clickable but specific buttons clickable** to avoid blocking touch events on the screen area underneath:
  ```cpp
  lv_obj_clear_flag(container, LV_OBJ_FLAG_CLICKABLE);
  lv_obj_clear_flag(container, LV_OBJ_FLAG_SCROLLABLE);
  ```

  4. **Add menu button** (left side of status bar). This button cycles through registered screens using ScreenManagerImpl::navigateTo(). The icon should be a simple "MENU" text or LV_SYMBOL_LIST. Make this button clickable:
  ```cpp
  lv_obj_add_flag(menuBtn, LV_OBJ_FLAG_CLICKABLE);
  ```
  The menu button callback calls `ScreenManagerImpl::getInstance()->navigateTo(nextScreenType)` where nextScreenType cycles through registered screens. For Phase 1, this means cycling between JORNADA and NUMPAD.

  5. **Add back button** (right side of status bar, or left of menu). Uses LV_SYMBOL_LEFT or a "<" label. Calls `ScreenManagerImpl::getInstance()->goBack()`. This button is hidden by default and shown only when the navigation stack is non-empty.
  ```cpp
  void setBackVisible(bool visible);
  ```

  6. **Keep existing functionality:** ignition indicator (circle + text), tempo ignicao label, tempo jornada label, and message label. These are already implemented -- preserve them.

  7. **Layout inside the 480x40 container:**
  - Left: Back button (32x32, hidden by default) | Menu button (32x32)
  - Center-left: Ignition indicator circle (12px) + "IGN" label + tempo label
  - Center-right: Jornada tempo label
  - Right: Message label (auto-expanding)

  8. **Add method for ScreenManager integration:**
  ```cpp
  void setBackVisible(bool visible); // show/hide back button
  void setMenuCallback(std::function<void()> cb); // or use static pointer to ScreenManager
  ```

  Since this is embedded (avoid std::function overhead), use a static function pointer or have StatusBar hold a pointer to IScreenManager and call navigateTo/goBack directly.

  **Forward declaration** of ScreenManagerImpl in the header is sufficient (or use IScreenManager*). Prefer IScreenManager* for loose coupling.

  **Critical: display lock.** All LVGL calls in StatusBar must be wrapped in bsp_display_lock/unlock, following the existing pattern in the current status_bar.cpp.
  </action>
  <verify>
  `pio run` compiles with no errors. Grep for `lv_layer_top` in status_bar.cpp to confirm StatusBar lives on the persistent layer. Grep for `setBackVisible` in status_bar.h to confirm back button API exists.
  </verify>
  <done>StatusBar creates on lv_layer_top(), survives screen transitions, has menu button for screen cycling and back button for stack pop. Container is non-clickable (no touch blocking) but menu/back buttons are clickable. All existing ignition/timer/message functionality preserved.</done>
</task>

</tasks>

<verification>
1. `pio run` compiles successfully with no errors
2. `grep "lv_scr_load_anim" src/ui/screen_manager.cpp` shows at least 2 occurrences (push and pop)
3. `grep "lv_layer_top" src/ui/widgets/status_bar.cpp` shows at least 1 occurrence
4. `grep "IScreenManager" include/ui/screen_manager.h` confirms interface implementation
5. `grep "transitioning_" src/ui/screen_manager.cpp` confirms navigation guard
6. `grep "setBackVisible" include/ui/widgets/status_bar.h` confirms back button API
7. `grep "getLvScreen" include/interfaces/i_screen.h` confirms new method in interface
</verification>

<success_criteria>
ScreenManagerImpl implements IScreenManager with stack-based push/pop navigation, lv_scr_load_anim() transitions (250ms slide), and transition-guard protection. StatusBar lives on lv_layer_top() with menu and back buttons. The framework is ready to receive JornadaScreen and NumpadScreen (Plan 01-03).
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
