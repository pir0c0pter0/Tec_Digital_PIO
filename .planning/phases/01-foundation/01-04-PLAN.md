---
phase: 01-foundation
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - include/interfaces/i_nvs.h
  - include/services/nvs/nvs_manager.h
  - src/services/nvs/nvs_manager.cpp
  - src/main.cpp
  - src/ui/screens/jornada_screen.cpp
autonomous: false

must_haves:
  truths:
    - "Volume and brightness settings persist across device reboot"
    - "Active journey states per motorist persist across power loss and are restored on boot"
    - "NvsManager uses the dedicated nvs_data partition (not the system nvs partition)"
    - "Journey state struct uses packed attribute with version field for future migration"
    - "Corrupted or version-mismatched NVS data falls back to safe defaults"
  artifacts:
    - path: "include/interfaces/i_nvs.h"
      provides: "Abstract NVS service interface"
      contains: "class INvsManager"
    - path: "include/services/nvs/nvs_manager.h"
      provides: "NvsManager class declaration"
      contains: "class NvsManager"
    - path: "src/services/nvs/nvs_manager.cpp"
      provides: "NVS implementation using nvs_data partition"
      contains: "nvs_flash_init_partition"
  key_links:
    - from: "src/services/nvs/nvs_manager.cpp"
      to: "include/config/app_config.h"
      via: "Uses NVS_PARTITION_LABEL, NVS_NS_SETTINGS, NVS_NS_JORNADA constants"
      pattern: "NVS_PARTITION_LABEL"
    - from: "src/main.cpp"
      to: "src/services/nvs/nvs_manager.cpp"
      via: "main.cpp initializes NvsManager and restores settings on boot"
      pattern: "NvsManager.*init|restoreSettings"
    - from: "src/ui/screens/jornada_screen.cpp"
      to: "src/services/nvs/nvs_manager.cpp"
      via: "JornadaScreen saves/restores motorist journey state"
      pattern: "NvsManager.*saveJornada|loadJornada"
---

<objective>
Implement the NvsManager service for persisting volume/brightness settings and journey state per motorist using the dedicated nvs_data partition. Integrate with main.cpp boot sequence and JornadaScreen for automatic save/restore.

Purpose: This completes Phase 1's data persistence requirements. Volume and brightness survive reboots (enabling Phase 3's settings screen). Journey states survive power loss -- critical for a commercial vehicle tracker where the device may lose power unexpectedly.

Output: Working NvsManager with settings and journey persistence, integrated into boot and screen lifecycle.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

@include/config/app_config.h
@include/interfaces/i_jornada.h
@src/services/jornada/jornada_service.cpp
@src/main.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NvsManager service with settings and journey state persistence</name>
  <files>include/interfaces/i_nvs.h, include/services/nvs/nvs_manager.h, src/services/nvs/nvs_manager.cpp</files>
  <action>
  **Step 1: Create include/interfaces/i_nvs.h** with abstract interface:

  ```cpp
  class INvsManager {
  public:
      virtual ~INvsManager() = default;
      virtual bool init() = 0;

      // Settings
      virtual bool saveVolume(uint8_t volume) = 0;
      virtual uint8_t loadVolume(uint8_t defaultVal) = 0;
      virtual bool saveBrightness(uint8_t brightness) = 0;
      virtual uint8_t loadBrightness(uint8_t defaultVal) = 0;

      // Journey state per motorist
      virtual bool saveJornadaState(uint8_t motoristId, const void* state, size_t size) = 0;
      virtual bool loadJornadaState(uint8_t motoristId, void* state, size_t size) = 0;
      virtual bool clearJornadaState(uint8_t motoristId) = 0;
  };
  ```

  Use `extern "C" { }` guards and C-compatible enum like the other interfaces.

  **Step 2: Create include/services/nvs/nvs_manager.h:**

  Define the packed struct for journey state persistence:
  ```cpp
  struct __attribute__((packed)) NvsJornadaState {
      uint8_t version;                    // NVS_JORNADA_VERSION for migration
      uint8_t estadoAtual;                // Current EstadoJornada enum value (0-6)
      uint32_t tempoInicio;               // millis() snapshot when state started
      uint32_t tempoTotalJornada;         // Accumulated time in JORNADA state (ms)
      uint32_t tempoTotalManobra;
      uint32_t tempoTotalRefeicao;
      uint32_t tempoTotalEspera;
      uint32_t tempoTotalDescarga;
      uint32_t tempoTotalAbastecimento;
      bool ativo;                         // Is this motorist slot active
  };
  ```

  Class `NvsManager : public INvsManager` with:
  - Singleton pattern (static instance_, getInstance())
  - `bool init()` -- calls `nvs_flash_init_partition(NVS_PARTITION_LABEL)`. On `ESP_ERR_NVS_NO_FREE_PAGES` or `ESP_ERR_NVS_NEW_VERSION_FOUND`, erases and retries. Logs result with ESP_LOGI.
  - `bool saveVolume(uint8_t volume)` -- opens NVS_NS_SETTINGS namespace on NVS_PARTITION_LABEL, writes NVS_KEY_VOLUME via nvs_set_u8, commits, closes handle.
  - `uint8_t loadVolume(uint8_t defaultVal)` -- opens NVS_NS_SETTINGS, reads NVS_KEY_VOLUME. Returns defaultVal if key not found or error.
  - `bool saveBrightness(uint8_t brightness)` -- same pattern with NVS_KEY_BRIGHTNESS.
  - `uint8_t loadBrightness(uint8_t defaultVal)` -- same pattern.
  - `bool saveJornadaState(uint8_t motoristId, const void* state, size_t size)` -- opens NVS_NS_JORNADA, creates key `"mot_X"` where X is motoristId (0-2), writes via `nvs_set_blob()`, commits, closes.
  - `bool loadJornadaState(uint8_t motoristId, void* state, size_t size)` -- opens NVS_NS_JORNADA, reads blob via `nvs_get_blob()`. **Validates version field** after read: if `((NvsJornadaState*)state)->version != NVS_JORNADA_VERSION`, logs warning and returns false (caller uses defaults).
  - `bool clearJornadaState(uint8_t motoristId)` -- erases the key from NVS_NS_JORNADA.
  - Private helper: `bool openHandle(const char* ns, nvs_open_mode_t mode, nvs_handle_t* handle)` to reduce code duplication. Always uses `nvs_open_from_partition(NVS_PARTITION_LABEL, ...)`.

  **Critical details:**
  - All namespace names are <= 15 characters (NVS limit): "settings" (8), "jornada" (7).
  - All key names are <= 15 characters: "volume" (6), "brightness" (10), "mot_0" (5).
  - Every nvs_handle MUST be closed (nvs_close) in all code paths, including error paths. Use RAII or explicit cleanup.
  - The packed struct must NOT have any pointer members (NVS blob stores raw bytes).
  - Thread safety: NVS calls are already thread-safe per ESP-IDF docs, but wrap in a FreeRTOS mutex for extra safety since save may be called from different tasks.

  **Step 3: Create src/services/nvs/nvs_manager.cpp** implementing the above. Use ESP_LOGI/ESP_LOGW/ESP_LOGE for all operations. Log the partition label and namespace on init.
  </action>
  <verify>
  `pio run` compiles with no errors. Grep for `nvs_flash_init_partition` in nvs_manager.cpp. Grep for `nvs_set_blob` to confirm journey persistence. Grep for `__attribute__((packed))` to confirm struct packing.
  </verify>
  <done>NvsManager exists with init(), save/load for volume and brightness settings, and save/load/clear for packed journey state blobs per motorist. Uses dedicated nvs_data partition. Version field enables future migration. All handles properly closed.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate NvsManager with boot sequence and JornadaScreen</name>
  <files>src/main.cpp, src/ui/screens/jornada_screen.cpp</files>
  <action>
  **In main.cpp (system_task initialization, BEFORE screen creation):**

  1. Add include: `#include "services/nvs/nvs_manager.h"`
  2. Initialize NvsManager early in system_task (after splash, before audio init):
  ```cpp
  // Inicializa NVS (deve ser antes de qualquer leitura de configuracao)
  auto* nvsMgr = NvsManager::getInstance();
  if (!nvsMgr->init()) {
      ESP_LOGE(TAG, "Falha ao inicializar NVS! Usando valores padrao.");
  }
  ```

  3. Restore volume setting:
  ```cpp
  uint8_t savedVolume = nvsMgr->loadVolume(AUDIO_VOLUME_DEFAULT);
  ESP_LOGI(TAG, "Volume restaurado: %d", savedVolume);
  // Apply volume to audio system (call setVolume if SimpleAudioManager supports it,
  // or store in a global for the audio system to pick up)
  ```

  4. Restore brightness setting:
  ```cpp
  uint8_t savedBrightness = nvsMgr->loadBrightness(100);  // 100% default
  ESP_LOGI(TAG, "Brilho restaurado: %d%%", savedBrightness);
  // Apply brightness via bsp_display_backlight_brightness() if available,
  // or store for future SettingsScreen (Phase 3) to use
  ```

  **In JornadaScreen:**

  1. In `onEnter()` or `create()`, restore journey state for all 3 motorists:
  ```cpp
  NvsManager* nvs = NvsManager::getInstance();
  for (uint8_t i = 0; i < MAX_MOTORISTAS; i++) {
      NvsJornadaState state;
      if (nvs->loadJornadaState(i, &state, sizeof(state))) {
          // Apply loaded state to JornadaKeyboard's motorist state
          // This includes: estadoAtual, tempoInicio, accumulated times, ativo flag
          ESP_LOGI(TAG, "Motorista %d: estado=%d, ativo=%d", i, state.estadoAtual, state.ativo);
      }
  }
  ```

  2. In `onExit()` or when journey state changes (via callback), save state:
  ```cpp
  void JornadaScreen::saveJornadaState() {
      NvsManager* nvs = NvsManager::getInstance();
      for (uint8_t i = 0; i < MAX_MOTORISTAS; i++) {
          NvsJornadaState state;
          state.version = NVS_JORNADA_VERSION;
          // Populate from JornadaKeyboard's current state for motorist i
          state.estadoAtual = /* current state */;
          state.tempoInicio = /* start time */;
          // ... all accumulated times ...
          state.ativo = /* is active */;
          nvs->saveJornadaState(i, &state, sizeof(state));
      }
  }
  ```

  3. **Auto-save on state change:** Register a callback (or check periodically in update()) so that whenever a motorist's journey state changes (via processarAcao in JornadaKeyboard), the new state is persisted. Do NOT save on every update() tick -- only on actual state changes to minimize NVS wear. NVS flash has ~100K write cycles per sector.

  4. **Restore timing:** When restoring state, adjust tempoInicio based on current millis(). If the device was off for X seconds, the accumulated times should be preserved but tempoInicio should be recalculated:
  ```cpp
  // On restore, if motorist was active:
  // tempoInicio = millis() - (totalAccumulated - restoredAccumulated)
  // Or simpler: just set tempoInicio = millis() and keep accumulated times
  // This loses the "in-flight" time since last save, which is acceptable
  ```

  **Volume save trigger:** For Phase 1, volume save happens on value change. Since there's no SettingsScreen yet, the volume is only set at boot from NVS. The actual save-on-change will be wired in Phase 3 (SettingsScreen). For now, just the load-at-boot path needs to work.

  **Brightness save trigger:** Same as volume -- load at boot, save-on-change deferred to Phase 3.
  </action>
  <verify>
  `pio run` compiles with no errors. Grep for `NvsManager` in main.cpp to confirm init at boot. Grep for `saveJornadaState\|loadJornadaState` in jornada_screen.cpp to confirm journey persistence integration. Check serial output for NVS init and restore logs.
  </verify>
  <done>NvsManager initializes on boot using nvs_data partition. Volume and brightness are restored from NVS at boot (defaulting to AUDIO_VOLUME_DEFAULT and 100% if not yet saved). Journey state for all 3 motorists is saved on state changes and restored on JornadaScreen entry. Corrupted/missing data falls back to safe defaults.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify NVS persistence survives power cycle on hardware</name>
  <files>src/main.cpp, src/ui/screens/jornada_screen.cpp</files>
  <action>
  Flash firmware and verify NVS persistence on hardware. What was built: NVS persistence service integrated with boot sequence and JornadaScreen. Settings (volume, brightness) and journey states should survive power cycles.

  Verification steps:
  1. Flash firmware: `pio run --target upload && pio run --target uploadfs`
  2. Open serial monitor: `pio device monitor`
  3. Verify NVS init: Look for "NVS" log messages showing successful initialization of nvs_data partition
  4. Verify settings restore: Look for "Volume restaurado" and "Brilho restaurado" in boot log
  5. Navigate to JornadaScreen and activate a journey state for Motorist 1 (e.g., tap Jornada, select Motorista 1)
  6. Wait a few seconds to accumulate some time-in-state
  7. Power cycle the device (disconnect USB, reconnect)
  8. After reboot, navigate to JornadaScreen
  9. Verify Motorist 1 shows the previously saved journey state (correct action button should show the motorist indicator)
  10. Verify serial log shows journey state restoration messages
  11. Repeat navigation test (menu/back buttons) to ensure NVS operations don't cause latency or crashes

  Resume signal: Type "approved" if persistence works correctly, or describe specific issues found.
  </action>
  <verify>User confirms all 11 verification steps pass on hardware, especially that journey state survives power cycle.</verify>
  <done>NVS persistence verified on hardware: volume/brightness restored at boot, journey states survive power cycle, no latency or crashes from NVS operations.</done>
</task>

</tasks>

<verification>
1. `pio run` compiles successfully with no errors
2. `grep "nvs_flash_init_partition" src/services/nvs/nvs_manager.cpp` confirms custom partition init
3. `grep "NVS_PARTITION_LABEL" src/services/nvs/nvs_manager.cpp` confirms using app_config constant
4. `grep "NvsManager" src/main.cpp` confirms boot integration
5. `grep "saveJornadaState\|loadJornadaState" src/ui/screens/jornada_screen.cpp` confirms journey persistence
6. `grep "__attribute__((packed))" include/services/nvs/nvs_manager.h` confirms struct packing
7. Serial output shows NVS initialization, volume/brightness restore, and journey state save/restore logs
</verification>

<success_criteria>
NvsManager uses dedicated nvs_data partition. Volume and brightness are loaded at boot with correct defaults. Journey state for all 3 motorists is saved on state change and restored on next boot. Version field in packed struct enables future migration. No NVS errors in serial log. Device operates normally with NVS operations (no UI latency or crashes).
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
