---
phase: 01.1-screen-infrastructure-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/button_manager.h
  - src/button_manager.cpp
autonomous: true

must_haves:
  truths:
    - "ButtonManager event handlers never fall back to singleton when user_data is null"
    - "Popup debounce is per-ButtonManager instance, not shared static"
    - "ButtonManager destructor safely deletes LVGL screen even when active"
  artifacts:
    - path: "include/button_manager.h"
      provides: "lastPopupClickTime_ member variable for per-instance debounce"
      contains: "lastPopupClickTime_"
    - path: "src/button_manager.cpp"
      provides: "Safe destructor, no singleton fallback, per-instance debounce"
  key_links:
    - from: "ButtonManager::buttonEventHandler"
      to: "ESP_LOGE + return"
      via: "null user_data guard"
      pattern: "ESP_LOGE.*null user_data"
    - from: "ButtonManager::popupButtonHandler"
      to: "mgr->lastPopupClickTime_"
      via: "per-instance debounce member"
      pattern: "mgr->lastPopupClickTime_"
    - from: "ButtonManager::~ButtonManager"
      to: "lv_obj_del(screen)"
      via: "unconditional deletion with active screen guard"
      pattern: "lv_obj_del\\(screen\\)"
---

<objective>
Harden ButtonManager event handlers and destructor for multi-screen isolation.

Purpose: Eliminate three defects that cause cross-screen state leaks and memory leaks when multiple ButtonManager instances exist: (1) singleton fallback in event handlers routes events to wrong screen, (2) static debounce timestamp is shared across all popup instances, (3) destructor skips deletion of active screen causing LVGL object leak.

Output: ButtonManager with safe event isolation, per-instance debounce, and leak-free destructor.
</objective>

<execution_context>
@/home/mariostjr/.claude/get-shit-done/workflows/execute-plan.md
@/home/mariostjr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-screen-infrastructure-hardening/01.1-RESEARCH.md
@include/button_manager.h
@src/button_manager.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Eliminate singleton fallback in event handlers + add per-instance popup debounce</name>
  <files>include/button_manager.h, src/button_manager.cpp</files>
  <action>
  Three changes to ButtonManager for event isolation:

  **1. Add per-instance popup debounce member (button_manager.h):**
  - Add `unsigned long lastPopupClickTime_;` to the private section, near the existing `lastButtonClickTime_` and `lastButtonClickedId_` members (around line 168).
  - Initialize to `0` in the ButtonManager constructor.

  **2. Fix buttonEventHandler (button_manager.cpp ~line 1066-1074):**
  - Current code: if `mgr` is null, falls back to `getInstance()`.
  - New code: if `mgr` is null, log error with `ESP_LOGE("BTN_MGR", "buttonEventHandler: null user_data on button ID=%d", buttonId);` and `return;` immediately. Do NOT call `getInstance()`.
  - Keep all other logic in the handler unchanged.

  **3. Fix popupButtonHandler (button_manager.cpp ~line 1096-1120):**
  - Current code: uses `static unsigned long lastPopupClickTime = 0;` for debounce.
  - New code:
    a. Resolve `ButtonManager* mgr` from `lv_obj_get_user_data(target)` (same pattern as buttonEventHandler).
    b. If `mgr` is null, log `ESP_LOGE("BTN_MGR", "popupButtonHandler: null user_data");` and return.
    c. Replace the static debounce variable with `mgr->lastPopupClickTime_` for comparison and update.
    d. Remove the `static unsigned long lastPopupClickTime = 0;` line entirely.
    e. Keep all other popup logic (callback invocation, closePopup) unchanged, but use `mgr->` prefix for instance access.

  **Also fix statusUpdateCallback and statusTimerHandler** if they use `getInstance()`:
  - These timer callbacks receive the ButtonManager pointer via `timer->user_data`. Verify they already use `timer->user_data` and not `getInstance()`. If they use `getInstance()`, change them to cast `timer->user_data` to `ButtonManager*` and guard null.

  Language: Comments in Portuguese (BR) per project convention. Use `ESP_LOGE` (not LOG_E) since button_manager.cpp uses ESP_LOGE directly.
  </action>
  <verify>
  Run `pio run` -- build must pass with zero errors. Grep for `getInstance()` in buttonEventHandler and popupButtonHandler -- must NOT appear. Grep for `static unsigned long lastPopupClickTime` -- must NOT appear.
  </verify>
  <done>
  buttonEventHandler and popupButtonHandler reject null user_data with ESP_LOGE instead of falling back to singleton. Popup debounce uses per-instance lastPopupClickTime_ member. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix ButtonManager destructor to safely delete LVGL screen in all cases</name>
  <files>src/button_manager.cpp</files>
  <action>
  Fix the ButtonManager destructor (~line 83-110) to always delete the LVGL screen object, including when it is the active screen.

  **Current problematic code (line ~93):**
  ```cpp
  if (screen != nullptr && screen != lv_scr_act()) {
      lv_obj_del(screen);
  }
  ```
  This skips deletion when screen IS the active screen, leaking all LVGL objects.

  **New destructor implementation:**
  ```cpp
  ButtonManager::~ButtonManager() {
      if (bsp_display_lock(200)) {
          // Deleta timers primeiro (evita callbacks em objetos deletados)
          if (retryTimer) { lv_timer_del(retryTimer); retryTimer = nullptr; }
          if (statusUpdateTimer) { lv_timer_del(statusUpdateTimer); statusUpdateTimer = nullptr; }
          if (statusTimer) { lv_timer_del(statusTimer); statusTimer = nullptr; }

          buttons.clear();

          // Sempre deleta o screen LVGL (LVGL 8.4.0 suporta deletar tela ativa)
          if (screen != nullptr) {
              if (screen == lv_scr_act()) {
                  // Caso extremo: cria tela temporaria antes de deletar a ativa
                  lv_obj_t* blank = lv_obj_create(NULL);
                  lv_scr_load(blank);
              }
              lv_obj_del(screen);
          }
          screen = nullptr;

          bsp_display_unlock();
      }

      if (creationMutex) {
          vSemaphoreDelete(creationMutex);
          creationMutex = nullptr;
      }
  }
  ```

  **Key points:**
  - Delete timers BEFORE deleting screen (timers may reference screen children).
  - Clear `buttons` vector to release std::function captures before LVGL objects go away.
  - If screen is the active screen, load a blank temp screen first, then delete ours. This avoids LVGL setting `disp->act_scr = NULL` which would leave rendering in undefined state.
  - In normal ScreenManager flow, the new screen is loaded BEFORE destroy(), so this edge case rarely triggers. But it must be safe for direct `delete buttonManager` calls.
  - Always null out screen pointer after deletion.
  - Mutex deletion happens OUTSIDE display lock (cannot hold two locks).

  Preserve any existing cleanup the destructor already does (like `buttons.clear()`, mutex deletion) -- just restructure to delete screen unconditionally.
  </action>
  <verify>
  Run `pio run` -- build must pass with zero errors. Read the destructor and confirm: no conditional skip of lv_obj_del based on lv_scr_act() check.
  </verify>
  <done>
  ButtonManager destructor always deletes its LVGL screen object. Active screen case handled by loading blank screen first. Timers cleaned up before screen deletion. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `pio run` passes with zero errors
2. `grep -n "getInstance()" src/button_manager.cpp` -- only appears in the `getInstance()` method definition and `destroyInstance()`, NOT in buttonEventHandler or popupButtonHandler
3. `grep -n "static unsigned long lastPopupClickTime" src/button_manager.cpp` -- zero matches
4. `grep -n "screen != lv_scr_act()" src/button_manager.cpp` -- zero matches in destructor (the conditional skip is removed)
5. `grep -n "lastPopupClickTime_" include/button_manager.h` -- exactly one match (member declaration)
</verification>

<success_criteria>
- ButtonManager event handlers reject null user_data with error log, never fall back to singleton
- Popup debounce is per-instance via lastPopupClickTime_ member variable
- Destructor safely deletes LVGL screen even when it is the active screen
- Build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-screen-infrastructure-hardening/01.1-01-SUMMARY.md`
</output>
