# Phase 1.1: Screen Infrastructure Hardening - Research

**Researched:** 2026-02-10
**Domain:** LVGL 8.4.0 screen lifecycle, C++ singleton removal, embedded multi-instance architecture
**Confidence:** HIGH

## Summary

Phase 1.1 hardens the screen infrastructure that was built in Phase 1. The existing code has six specific defects that prevent true multi-screen isolation: (1) event handlers fall back to `ButtonManager::getInstance()` when `user_data` is null, (2) `JornadaKeyboard` and `NumpadExample` are singletons that store a single `ButtonManager*`, (3) popup debounce uses a `static` local variable shared across all instances, (4) `ButtonManager::~ButtonManager()` skips `lv_obj_del()` when the screen is the active screen, (5) `ButtonManager::createScreen()` creates an internal status bar that duplicates the persistent `StatusBar` widget on `lv_layer_top()`, and (6) the legacy `init()` (no-args) method uses `ButtonManager::getInstance()`.

This research analyzes the LVGL 8.4.0 source code bundled in the project to provide verified, definitive guidance on screen deletion, event handler safety, and object lifecycle. All findings come directly from reading the project source code and the LVGL library source in `lib/lvgl/`. The singleton pattern in `JornadaKeyboard` and `NumpadExample` creates a fundamental architectural conflict: both `JornadaScreen` and `NumpadScreen` already call `new ButtonManager()` for per-screen isolation, but then call `getInstance()` to obtain the domain logic objects -- which means all screens share the same `JornadaKeyboard` and `NumpadExample` instances, and those instances can only point to one `ButtonManager` at a time.

**Primary recommendation:** Fix the six defects in three plans: (1) eliminate singleton fallback + fix static debounce + fix destructor, (2) convert JornadaKeyboard and NumpadExample to per-screen instances, (3) remove internal StatusBar from ButtonManager + cleanup legacy init().

## Standard Stack

### Core (all already in project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| LVGL | 8.4.0 (lib/lvgl/) | GUI framework | Local copy, screen/object management |
| ESP-IDF | 5.3.1 | Platform framework | FreeRTOS, RTOS primitives |
| FreeRTOS | Bundled | Thread synchronization | Mutexes for display lock |

### No New Dependencies Required
This phase is pure refactoring of existing C++ code. No new libraries needed.

## Architecture Patterns

### Pattern 1: Per-Screen Instance Ownership (replacing singletons)
**What:** Each `IScreen` implementation owns its own instances of domain logic classes (JornadaKeyboard, NumpadExample), not shared singletons.
**When to use:** Always -- this is the target architecture.

**Current (broken) flow:**
```
JornadaScreen::create()
    btnManager_ = new ButtonManager();        // OK: per-screen
    jornadaKb_ = JornadaKeyboard::getInstance(); // BAD: singleton shared
    jornadaKb_->init(btnManager_);            // Overwrites previous btnManager_ ref
```

**Target flow:**
```
JornadaScreen::create()
    btnManager_ = new ButtonManager();       // OK: per-screen
    jornadaKb_ = new JornadaKeyboard();      // OK: per-screen instance
    jornadaKb_->init(btnManager_);           // OK: this instance's ButtonManager
```

### Pattern 2: Safe LVGL Screen Deletion
**What:** LVGL 8.4.0 CAN delete the active screen. The library sets `disp->act_scr = NULL` and logs a warning, but the object IS freed. The current code in `ButtonManager::~ButtonManager()` incorrectly skips deletion.

**Source verification (lib/lvgl/src/core/lv_obj_tree.c:45-78):**
```c
void lv_obj_del(lv_obj_t * obj) {
    lv_obj_t * par = lv_obj_get_parent(obj);
    lv_disp_t * disp = NULL;
    bool act_scr_del = false;
    if(par == NULL) {
        disp = lv_obj_get_disp(obj);
        if(!disp) return;
        if(disp->act_scr == obj) act_scr_del = true;
    }
    obj_del_core(obj);   // <-- DOES delete the object
    if(act_scr_del) {
        LV_LOG_WARN("the active screen was deleted");
        disp->act_scr = NULL;  // <-- sets active to NULL
    }
}
```

**Safe deletion pattern:** Before deleting the active screen, load a different screen first:
```cpp
if (screen != nullptr) {
    if (screen == lv_scr_act()) {
        // Create a blank temporary screen, load it, then delete ours
        lv_obj_t* blank = lv_obj_create(NULL);
        lv_scr_load(blank);
    }
    lv_obj_del(screen);
    screen = nullptr;
}
```

**However**, in the ScreenManagerImpl context, the ScreenManager always calls `lv_scr_load(newScreen)` BEFORE calling `destroy()` on the old screen. So the destructor will almost never encounter `screen == lv_scr_act()` in normal flow. The fix should handle the edge case defensively (e.g., direct `delete buttonManager` without going through ScreenManager).

### Pattern 3: Event Handler Instance Resolution (no singleton fallback)
**What:** LVGL event handlers are `static` functions. They resolve the correct instance via `lv_obj_get_user_data()`. If user_data is null, they must NOT fall back to a singleton.

**Current (broken) code (button_manager.cpp:1066-1074):**
```cpp
void ButtonManager::buttonEventHandler(lv_event_t* e) {
    lv_obj_t* target = lv_event_get_target(e);
    ButtonManager* mgr = static_cast<ButtonManager*>(lv_obj_get_user_data(target));
    if (!mgr) {
        mgr = getInstance(); // <-- WRONG: falls back to singleton
    }
    // ...
}
```

**Target code:**
```cpp
void ButtonManager::buttonEventHandler(lv_event_t* e) {
    lv_obj_t* target = lv_event_get_target(e);
    ButtonManager* mgr = static_cast<ButtonManager*>(lv_obj_get_user_data(target));
    if (!mgr) {
        ESP_LOGE(TAG, "buttonEventHandler: null user_data, ignoring event");
        return;  // <-- SAFE: reject event
    }
    // ...
}
```

### Pattern 4: Per-Instance Debounce State
**What:** Debounce timestamps must be instance members, not static locals.

**Current (broken) code (button_manager.cpp:1106):**
```cpp
void ButtonManager::popupButtonHandler(lv_event_t* e) {
    // ...
    static unsigned long lastPopupClickTime = 0;  // <-- SHARED across all instances
    // ...
}
```

**Target code:** Move to instance member (already partially done for button debounce via `lastButtonClickTime_` and `lastButtonClickedId_`):
```cpp
// In ButtonManager header:
unsigned long lastPopupClickTime_;  // per-instance

// In popupButtonHandler:
void ButtonManager::popupButtonHandler(lv_event_t* e) {
    ButtonManager* mgr = static_cast<ButtonManager*>(lv_obj_get_user_data(target));
    if (!mgr) { return; }
    if ((currentTime - mgr->lastPopupClickTime_) < BUTTON_DEBOUNCE_MS) { return; }
    mgr->lastPopupClickTime_ = currentTime;
    // ...
}
```

### Pattern 5: Domain Logic Callback Resolution Without Singleton
**What:** JornadaKeyboard's static callbacks (`onActionButtonClick`, `onMotoristaSelectClick`, `onCancelPopupClick`) all call `getInstance()` to find the JornadaKeyboard instance. Once JornadaKeyboard is no longer a singleton, these must resolve the instance differently.

**Strategy:** Pass `this` pointer through the callback chain. JornadaKeyboard's button callbacks receive a `buttonId` (from `std::function<void(int)>`). The JornadaKeyboard instance must be reachable from this context.

**Option A (recommended): Store JornadaKeyboard* in closure capture:**
```cpp
// In JornadaKeyboard::createKeyboard():
JornadaKeyboard* self = this;
def.callback = [self](int buttonId) {
    self->onActionButtonClickInstance(buttonId);
};
```
This works because `std::function<void(int)>` already supports lambdas with captures.

**Option B: Store pointer in ButtonManager user_data chain:**
Would require modifying ButtonManager to carry additional user data per button -- more invasive.

**For popup callbacks** (`onMotoristaSelectClick`, `onCancelPopupClick`):
These are raw LVGL event callbacks. Use `lv_obj_set_user_data()` on the popup buttons to store the JornadaKeyboard pointer:
```cpp
lv_obj_set_user_data(btnMotorista, this);
lv_obj_add_event_cb(btnMotorista, onMotoristaSelectClick, LV_EVENT_CLICKED, (void*)(intptr_t)i);
```
Then retrieve `this` from the parent or target's user_data in the callback.

**NumpadExample** has the same pattern -- its static callbacks (`onDigitClick`, `onOkClick`, `onCancelClick`) all call `getInstance()`. Same fix applies: capture `this` in lambdas or pass through user_data.

### Anti-Patterns to Avoid
- **Singleton for per-screen domain logic:** JornadaKeyboard and NumpadExample must NOT be singletons because multiple screen instances need independent state
- **Static local variables in static callbacks:** These create shared state across instances -- use instance members instead
- **Conditional fallback to singleton in event handlers:** This masks bugs and cross-talks between screens
- **Skipping LVGL object deletion for active screen:** The object leaks; LVGL supports deleting the active screen

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Screen switching safety | Custom "safe delete" with temp screens | ScreenManager flow guarantee | ScreenManager always loads new screen before destroying old one; destructor just needs to handle edge cases |
| Debounce across instances | Custom per-button timestamp maps | Instance member variables | ButtonManager already has `lastButtonClickTime_` / `lastButtonClickedId_` for buttons; just add `lastPopupClickTime_` for popups |
| Callback instance resolution | Complex registration systems | Lambda captures + lv_obj user_data | std::function already supports captures; LVGL user_data is per-object |

## Common Pitfalls

### Pitfall 1: JornadaKeyboard Singleton Still Used in Static Callbacks
**What goes wrong:** After making JornadaKeyboard non-singleton, the static callbacks `onActionButtonClick()`, `onMotoristaSelectClick()`, and `onCancelPopupClick()` still call `getInstance()` which returns the old singleton or creates a new unwanted instance.
**Why it happens:** Static member functions cannot access `this`. The old pattern relied on singleton for instance resolution.
**How to avoid:** Convert button callbacks to lambdas that capture `this`. For LVGL event callbacks, store `this` via `lv_obj_set_user_data()`.
**Warning signs:** After refactoring, buttons on one screen trigger actions on a different screen's JornadaKeyboard.

### Pitfall 2: NumpadExample Has a Hidden Global Pointer
**What goes wrong:** `numpad_example.cpp` line 35 has `static NumpadExample* g_numpadInstance = nullptr;` used by the timeout timer callback. If two NumpadScreen instances exist, this global points to the last one created.
**Why it happens:** The timeout timer callback (`timeoutTimerCallback`) was set up with `NULL` user_data (line 327: `lv_timer_create(timeoutTimerCallback, 1000, NULL)`) and retrieves the instance via the global.
**How to avoid:** Pass `this` as user_data to `lv_timer_create()`. Remove `g_numpadInstance`.
**Warning signs:** Timeout fires on the wrong numpad instance, or on a destroyed instance.

### Pitfall 3: Destructor Memory Leak for Active Screen
**What goes wrong:** If `ButtonManager` is deleted while its screen is the active LVGL screen, the destructor skips `lv_obj_del(screen)` (line 93). The LVGL screen object and all children are leaked.
**Why it happens:** The original developer assumed deleting the active screen was unsafe in LVGL.
**How to avoid:** LVGL 8.4.0 can safely delete the active screen (verified in source). Load a blank screen first, then delete. Or simply always delete (LVGL handles `act_scr = NULL`).
**Warning signs:** Heap usage grows after repeated screen transitions.

### Pitfall 4: ButtonManager Internal StatusBar Conflicts with Persistent StatusBar
**What goes wrong:** `ButtonManager::createScreen()` (line 155) creates a `statusBar` lv_obj as a child of the screen object. This is a 40px-tall bar at the bottom. Meanwhile, the persistent `StatusBar` widget lives on `lv_layer_top()` and is also 40px at the bottom. They overlap and the internal one receives events meant for the persistent one.
**Why it happens:** The internal statusBar was the v1.x implementation. The persistent StatusBar was added in Phase 1 but the internal one was never removed.
**How to avoid:** Remove the internal statusBar creation from `ButtonManager::createScreen()`. Remove related labels (statusIgnicao, statusTempoIgnicao, statusTempoJornada, statusMensagem) and the `updateStatusBar()` method. The persistent `StatusBar` handles all status display.
**Warning signs:** Duplicate status bars visible on screen; touch events intercepted by wrong bar.

### Pitfall 5: Old ScreenManager Class in jornada_keyboard.h Still Exists
**What goes wrong:** There is an old `ScreenManager` class defined in `jornada_keyboard.h` (lines 119-157) that is different from `ScreenManagerImpl` in `ui/screen_manager.h`. Both have static `instance` pointers. The old one is dead code but still compiles and its `instance` is initialized.
**Why it happens:** Phase 1 created `ScreenManagerImpl` but never removed the old `ScreenManager` class.
**How to avoid:** Remove the old `ScreenManager` class from `jornada_keyboard.h` and its implementation from `jornada_keyboard.cpp` (lines 832-1067). Also remove the extern "C" functions `initScreenManager()`, `showNumpadKeyboard()`, `showJornadaKeyboard()`, `toggleKeyboard()`.
**Warning signs:** Build warnings about unused variables; confusion about which ScreenManager to use.

### Pitfall 6: JornadaKeyboard Stores ButtonManager* But Status Messages Go Through It
**What goes wrong:** After converting to per-screen instances, `JornadaKeyboard::processarAcao()` (line 718) calls `btnManager->setStatusMessage()` which updates the internal (now-removed) status bar, not the persistent StatusBar.
**Why it happens:** JornadaKeyboard was designed before the persistent StatusBar existed.
**How to avoid:** JornadaKeyboard should either (a) receive a `StatusBar*` reference like NumpadExample does, or (b) continue calling `btnManager->setStatusMessage()` which should be rewired to forward to the persistent StatusBar. Option (b) is simpler for this phase.
**Warning signs:** Status messages from jornada actions don't appear on screen.

## Code Examples

### 1. Safe ButtonManager Destructor
```cpp
// Source: verified against lib/lvgl/src/core/lv_obj_tree.c
ButtonManager::~ButtonManager() {
    if (bsp_display_lock(200)) {
        // Delete timers first
        if (retryTimer) { lv_timer_del(retryTimer); retryTimer = nullptr; }
        if (statusUpdateTimer) { lv_timer_del(statusUpdateTimer); statusUpdateTimer = nullptr; }
        if (statusTimer) { lv_timer_del(statusTimer); statusTimer = nullptr; }

        buttons.clear();

        // Always delete screen (LVGL handles active screen case)
        if (screen != nullptr) {
            if (screen == lv_scr_act()) {
                // Edge case: load blank screen first for safety
                lv_obj_t* blank = lv_obj_create(NULL);
                lv_scr_load(blank);
            }
            lv_obj_del(screen);
        }
        screen = nullptr;

        bsp_display_unlock();
    }

    if (creationMutex) {
        vSemaphoreDelete(creationMutex);
        creationMutex = nullptr;
    }
}
```

### 2. Event Handler Without Singleton Fallback
```cpp
// Source: current button_manager.cpp refactored
void ButtonManager::buttonEventHandler(lv_event_t* e) {
    int buttonId = (int)(intptr_t)lv_event_get_user_data(e);
    lv_obj_t* target = lv_event_get_target(e);
    ButtonManager* mgr = static_cast<ButtonManager*>(lv_obj_get_user_data(target));

    if (!mgr) {
        ESP_LOGE("BTN_MGR", "buttonEventHandler: null user_data on button ID=%d", buttonId);
        return;  // Do NOT fall back to getInstance()
    }

    unsigned long currentTime = millis();
    if (buttonId == mgr->lastButtonClickedId_ &&
        (currentTime - mgr->lastButtonClickTime_) < BUTTON_DEBOUNCE_MS) {
        return;
    }

    mgr->lastButtonClickTime_ = currentTime;
    mgr->lastButtonClickedId_ = buttonId;

    GridButton* btn = mgr->getButton(buttonId);
    if (btn && btn->enabled && btn->callback) {
        btn->callback(buttonId);
    }
}
```

### 3. Per-Instance Popup Debounce
```cpp
// In button_manager.h, add to private members:
unsigned long lastPopupClickTime_;  // Initialize to 0 in constructor

// In popupButtonHandler:
void ButtonManager::popupButtonHandler(lv_event_t* e) {
    PopupResult result = (PopupResult)(intptr_t)lv_event_get_user_data(e);
    lv_obj_t* target = lv_event_get_target(e);
    ButtonManager* mgr = static_cast<ButtonManager*>(lv_obj_get_user_data(target));

    if (!mgr) {
        ESP_LOGE("BTN_MGR", "popupButtonHandler: null user_data");
        return;
    }

    unsigned long currentTime = millis();
    // Per-instance debounce (not static)
    if ((currentTime - mgr->lastPopupClickTime_) < BUTTON_DEBOUNCE_MS) {
        return;
    }
    mgr->lastPopupClickTime_ = currentTime;

    mgr->lastPopupResult = result;
    if (mgr->popupCallback) {
        mgr->popupCallback(result);
    }
    mgr->closePopup();
}
```

### 4. JornadaKeyboard Per-Screen Instance (lambda callbacks)
```cpp
// In JornadaKeyboard::createKeyboard(), replace static callback:
// BEFORE:
//   def.callback = onActionButtonClick;  // static function uses getInstance()
// AFTER:
JornadaKeyboard* self = this;
def.callback = [self](int buttonId) {
    // Find which action was clicked
    for (int i = 0; i < ACAO_MAX; i++) {
        if (self->botoes[i].buttonId == buttonId) {
            playAudioFile("/click.mp3");
            self->showMotoristaSelection(self->botoes[i].tipo);
            break;
        }
    }
};

// For LVGL popup callbacks, store JornadaKeyboard* in user_data:
// In showMotoristaSelection():
lv_obj_set_user_data(btnMotorista, this);  // Store JornadaKeyboard*
lv_obj_add_event_cb(btnMotorista, onMotoristaSelectClick, LV_EVENT_CLICKED,
                    (void*)(intptr_t)i);

// In onMotoristaSelectClick():
void JornadaKeyboard::onMotoristaSelectClick(lv_event_t* e) {
    int motorista = (int)(intptr_t)lv_event_get_user_data(e);
    lv_obj_t* target = lv_event_get_target(e);
    JornadaKeyboard* jornada = static_cast<JornadaKeyboard*>(lv_obj_get_user_data(target));
    if (!jornada) {
        ESP_LOGE("JORNADA_KB", "onMotoristaSelectClick: null user_data");
        return;
    }
    jornada->processarAcao(motorista, jornada->acaoPendente);
    jornada->closeMotoristaSelection();
}
```

### 5. NumpadExample Per-Screen Instance (fixing timeout timer)
```cpp
// Fix timeout timer to use this pointer instead of global:
void NumpadExample::startTimeoutTimer() {
    if (timeoutTimer) {
        lv_timer_del(timeoutTimer);
    }
    // Pass this instead of NULL
    timeoutTimer = lv_timer_create(timeoutTimerCallback, 1000, this);
}

// In timeoutTimerCallback:
void NumpadExample::timeoutTimerCallback(lv_timer_t* timer) {
    NumpadExample* numpad = static_cast<NumpadExample*>(timer->user_data);
    if (!numpad) return;
    // ... rest of logic using numpad-> instead of g_numpadInstance->
}
```

## Detailed Issue Analysis

### Issue 1: ButtonManager Event Handler Singleton Fallback
**Location:** `src/button_manager.cpp` lines 1072-1073, 1100-1102
**Severity:** HIGH -- cross-screen event leakage
**Current behavior:** If `lv_obj_get_user_data(target)` returns null, falls back to `ButtonManager::getInstance()`. This means events could route to the wrong screen's ButtonManager.
**Why it exists:** Safety net from before per-screen ButtonManagers were introduced.
**Fix:** Return early with error log. The `user_data` is set correctly in `addButtonInternal()` (line 364: `lv_obj_set_user_data(newButton.obj, this)`) and `showPopup()` (lines 1027, 1041). If it's null, something is fundamentally wrong and processing should not continue.
**Risk:** LOW -- user_data is always set for properly created buttons.

### Issue 2: JornadaKeyboard and NumpadExample Singleton Pattern
**Location:** `include/jornada_keyboard.h` line 66, `include/numpad_example.h` line 54
**Severity:** HIGH -- prevents multi-screen instances
**Current behavior:** Both use classic singleton: `static T* instance; static T* getInstance()`. `JornadaScreen::create()` calls `JornadaKeyboard::getInstance()` (jornada_screen.cpp:57) getting the shared singleton. If two JornadaScreens existed, both would share the same JornadaKeyboard instance, and calling `init(btnManager_)` would overwrite the previous screen's ButtonManager pointer.
**Fix:**
1. Make constructor public (already is for JornadaKeyboard)
2. Change `JornadaScreen::create()` to `jornadaKb_ = new JornadaKeyboard()` instead of `getInstance()`
3. Change `NumpadScreen::create()` to `numpad_ = new NumpadExample()` instead of `getInstance()`
4. Keep `getInstance()` method for backward compatibility with legacy code paths but add deprecation comment
5. Update all 3 static callbacks in JornadaKeyboard to use lambda captures or user_data
6. Update all 3 static callbacks in NumpadExample to use lambda captures or user_data
7. Remove `g_numpadInstance` global and fix timeout timer
**Risk:** MEDIUM -- callbacks are the complex part; lambdas with captures work with `std::function<void(int)>`.

### Issue 3: Static Debounce in popupButtonHandler
**Location:** `src/button_manager.cpp` line 1106
**Severity:** MEDIUM -- popup debounce shared across screens
**Current behavior:** `static unsigned long lastPopupClickTime = 0;` is shared across all ButtonManager instances. If two screens have popups open (unlikely but possible), debounce from one affects the other.
**Fix:** Add `unsigned long lastPopupClickTime_` member to `ButtonManager`. Initialize to 0 in constructor. Use `mgr->lastPopupClickTime_` in handler.
**Risk:** LOW -- straightforward member variable addition.

### Issue 4: ButtonManager Destructor Skips Active Screen Deletion
**Location:** `src/button_manager.cpp` line 93
**Severity:** HIGH -- memory leak
**Current behavior:** `if (screen != nullptr && screen != lv_scr_act()) { lv_obj_del(screen); }` -- skips deletion if screen is active.
**LVGL 8.4.0 behavior (verified):** `lv_obj_del()` handles active screens by setting `disp->act_scr = NULL` after deletion. The object IS freed. It's safe to delete.
**Fix:** Always delete the screen. For safety, load a blank screen first if it's the active one, then delete. In normal ScreenManager flow, the screen won't be active because ScreenManager loads the new screen before calling destroy.
**Risk:** LOW -- LVGL handles this case explicitly.

### Issue 5: ButtonManager Internal StatusBar Duplication
**Location:** `src/button_manager.cpp` lines 155-200
**Severity:** MEDIUM -- visual overlap, wasted resources
**Current behavior:** `createScreen()` creates `statusBar`, `statusIgnicao`, `statusTempoIgnicao`, `statusTempoJornada`, `statusMensagem` as children of the ButtonManager's screen. These overlap with the persistent `StatusBar` on `lv_layer_top()`.
**Fix:** Remove the internal statusBar creation block (lines 155-200) and the `statusUpdateCallback` timer. Remove `updateStatusBar()`, `setStatusMessage()`, `clearStatusMessage()` methods OR keep them as facades that forward to the persistent StatusBar.
**Complication:** JornadaKeyboard calls `btnManager->setStatusMessage()` (line 370, 718, 732). NumpadExample uses `statusBar_` (persistent StatusBar) directly. Need to decide: remove these calls from JornadaKeyboard, or provide a bridge.
**Risk:** MEDIUM -- needs careful audit of all `setStatusMessage()` call sites.

### Issue 6: Legacy init() Uses Singleton
**Location:** `src/button_manager.cpp` line 130-132, and `buttonManagerInit()` at line 1223
**Severity:** LOW -- these code paths may be dead code in the new architecture
**Current behavior:** `ButtonManager::init()` just calls `createScreen()`. The `buttonManagerInit()` extern C function and `initButtonManager()` call `getInstance()`.
**Fix:** Keep `init()` as-is (it works fine for non-singleton instances). Remove or deprecate `buttonManagerInit()`, `initButtonManager()`, and the extern C wrappers if they are no longer called from `main.cpp`.
**Verification needed:** Check if `main.cpp` or any other file calls these functions.
**Risk:** LOW -- these appear to be legacy functions not used in the new architecture.

## Call Site Audit

### JornadaKeyboard::getInstance() call sites (4 total):
1. `jornada_keyboard.cpp:94` -- Singleton definition (remove `static instance`)
2. `jornada_keyboard.cpp:788` -- `onActionButtonClick` static callback (replace with lambda)
3. `jornada_keyboard.cpp:812` -- `onMotoristaSelectClick` static callback (use user_data)
4. `jornada_keyboard.cpp:820` -- `onCancelPopupClick` static callback (use user_data)
5. `jornada_screen.cpp:57` -- Screen creation (change to `new JornadaKeyboard()`)
6. `jornada_keyboard.cpp:867` -- Old ScreenManager init (dead code, remove)

### NumpadExample::getInstance() call sites (8 total):
1. `numpad_example.cpp:63` -- Singleton definition (remove `static instance`)
2. `numpad_example.cpp:456` -- `onDigitClick` static callback (replace with lambda)
3. `numpad_example.cpp:469` -- `onOkClick` static callback (replace with lambda)
4. `numpad_example.cpp:539` -- `onCancelClick` static callback (replace with lambda)
5. `numpad_screen.cpp:57` -- Screen creation (change to `new NumpadExample()`)
6. `main.cpp:167` -- `setStatusBar(&statusBar)` call (needs alternative approach)
7. `numpad_example.cpp:572` -- `showNumpad()` global helper (dead code, remove or update)
8. `numpad_example.cpp:580` -- `hideNumpad()` global helper (dead code, remove or update)
9. `numpad_example.cpp:599` -- `numpadInit()` extern C wrapper (dead code, remove)

### ButtonManager::getInstance() call sites (in domain logic, excluding ButtonManager itself):
1. `jornada_keyboard.cpp:106` -- `init()` no-args (keep for backward compat, but deprecate)
2. `jornada_keyboard.cpp:956,991` -- Old ScreenManager methods (dead code, remove)
3. `numpad_example.cpp:75` -- `init()` no-args (keep for backward compat, but deprecate)
4. `numpad_example.cpp:566,583` -- `showNumpad()`/`hideNumpad()` helpers (dead code)

### main.cpp Dependencies:
- Line 167: `NumpadExample::getInstance()->setStatusBar(&statusBar)` -- this needs to change. NumpadScreen should receive the StatusBar reference and pass it to its NumpadExample instance.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single ButtonManager singleton | Per-screen ButtonManager instances | Phase 1 (2026-02) | Enables multi-screen |
| Old ScreenManager in jornada_keyboard.h | ScreenManagerImpl in ui/screen_manager.h | Phase 1 (2026-02) | Proper IScreenManager |
| StatusBar inside ButtonManager screen | Persistent StatusBar on lv_layer_top() | Phase 1 (2026-02) | Survives screen transitions |
| Singleton domain logic | Needs per-screen instances | Phase 1.1 (this phase) | True isolation |

**Deprecated/outdated (to be removed in this phase):**
- `ScreenManager` class in `jornada_keyboard.h` -- replaced by `ScreenManagerImpl`
- `buttonManagerInit()`, `initButtonManager()` -- legacy extern C entry points
- `showNumpad()`, `hideNumpad()`, `showNumpadKeyboard()`, `showJornadaKeyboard()`, `toggleKeyboard()` -- legacy global helpers
- `createDefaultJornadaButtons()` -- legacy helper using singleton
- `g_numpadInstance` global pointer -- replaced by timer user_data
- Internal statusBar in ButtonManager -- replaced by persistent StatusBar widget
- `buttonManagerUpdateStatusBar()` extern C function -- replaced by StatusBar::update()

## Open Questions

1. **How should JornadaKeyboard access the persistent StatusBar?**
   - What we know: NumpadExample already has `setStatusBar(StatusBar*)`. JornadaKeyboard currently calls `btnManager->setStatusMessage()` which goes to the internal (now-removed) status bar.
   - What's unclear: Should JornadaKeyboard get its own `StatusBar*` reference, or should we keep `setStatusMessage()` on ButtonManager as a facade?
   - Recommendation: Add `setStatusBar(StatusBar*)` to JornadaKeyboard, matching NumpadExample pattern. JornadaScreen passes the StatusBar reference during creation. This is cleaner than maintaining a facade.

2. **Should ButtonManager::getInstance() and the static `instance` pointer be kept?**
   - What we know: The extern C wrappers (`buttonManagerInit`, `buttonManagerGetInstance`, `buttonManagerUpdateStatusBar`) use it. So does `initButtonManager()`.
   - What's unclear: Are any of these extern C functions called from non-C++ code?
   - Recommendation: Keep `getInstance()` for now (it's used by the extern C wrappers which may be needed for C compatibility) but mark it deprecated with a comment. The extern C wrapper `buttonManagerUpdateStatusBar` should be removed since the persistent StatusBar replaces it.

3. **How should NumpadScreen pass StatusBar to NumpadExample?**
   - What we know: Currently `main.cpp:167` calls `NumpadExample::getInstance()->setStatusBar(&statusBar)` directly.
   - Recommendation: NumpadScreen should have a `setStatusBar(StatusBar*)` method. main.cpp calls `numpadScreen.setStatusBar(&statusBar)` before or after `create()`. NumpadScreen forwards to its NumpadExample instance.

## Sources

### Primary (HIGH confidence)
- **lib/lvgl/src/core/lv_obj_tree.c:45-78** -- `lv_obj_del()` implementation, verified active screen deletion behavior
- **lib/lvgl/src/core/lv_disp.c:82-84** -- `lv_scr_load()` delegates to `lv_scr_load_anim()` with no animation
- **lib/lvgl/src/core/lv_disp.c:221-271** -- `lv_scr_load_anim()` implementation, verified auto_del and screen switching
- **src/button_manager.cpp** -- Full ButtonManager implementation, all 6 issues verified by direct code reading
- **src/jornada_keyboard.cpp** -- Full JornadaKeyboard + old ScreenManager, singleton patterns identified
- **src/numpad_example.cpp** -- Full NumpadExample, singleton + g_numpadInstance global identified
- **src/ui/screen_manager.cpp** -- ScreenManagerImpl implementation, screen switching flow verified
- **src/ui/screens/jornada_screen.cpp** -- JornadaScreen::create() flow verified
- **src/ui/screens/numpad_screen.cpp** -- NumpadScreen::create() flow verified
- **src/main.cpp** -- Boot sequence and StatusBar setup verified

### No External Sources Needed
This phase is entirely about the project's own code. All findings come from direct analysis of the codebase and the bundled LVGL 8.4.0 library source.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new libraries, fully verified from project source
- Architecture: HIGH -- all patterns derived from reading actual LVGL source code and current codebase
- Pitfalls: HIGH -- all 6 issues verified with exact line numbers in source code
- Code examples: HIGH -- patterns verified against LVGL 8.4.0 API in lib/lvgl/

**Research date:** 2026-02-10
**Valid until:** Until next Phase 1 code change (stable -- this is internal refactoring)
